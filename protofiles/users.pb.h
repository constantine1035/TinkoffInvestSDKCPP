// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: users.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_users_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_users_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "google/api/field_behavior.pb.h"
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_users_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_users_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_users_2eproto;
namespace tinkoff {
namespace public_ {
namespace invest {
namespace api {
namespace contract {
namespace v1 {
class Account;
struct AccountDefaultTypeInternal;
extern AccountDefaultTypeInternal _Account_default_instance_;
class GetAccountsRequest;
struct GetAccountsRequestDefaultTypeInternal;
extern GetAccountsRequestDefaultTypeInternal _GetAccountsRequest_default_instance_;
class GetAccountsResponse;
struct GetAccountsResponseDefaultTypeInternal;
extern GetAccountsResponseDefaultTypeInternal _GetAccountsResponse_default_instance_;
class GetInfoRequest;
struct GetInfoRequestDefaultTypeInternal;
extern GetInfoRequestDefaultTypeInternal _GetInfoRequest_default_instance_;
class GetInfoResponse;
struct GetInfoResponseDefaultTypeInternal;
extern GetInfoResponseDefaultTypeInternal _GetInfoResponse_default_instance_;
class GetMarginAttributesRequest;
struct GetMarginAttributesRequestDefaultTypeInternal;
extern GetMarginAttributesRequestDefaultTypeInternal _GetMarginAttributesRequest_default_instance_;
class GetMarginAttributesResponse;
struct GetMarginAttributesResponseDefaultTypeInternal;
extern GetMarginAttributesResponseDefaultTypeInternal _GetMarginAttributesResponse_default_instance_;
class GetUserTariffRequest;
struct GetUserTariffRequestDefaultTypeInternal;
extern GetUserTariffRequestDefaultTypeInternal _GetUserTariffRequest_default_instance_;
class GetUserTariffResponse;
struct GetUserTariffResponseDefaultTypeInternal;
extern GetUserTariffResponseDefaultTypeInternal _GetUserTariffResponse_default_instance_;
class StreamLimit;
struct StreamLimitDefaultTypeInternal;
extern StreamLimitDefaultTypeInternal _StreamLimit_default_instance_;
class UnaryLimit;
struct UnaryLimitDefaultTypeInternal;
extern UnaryLimitDefaultTypeInternal _UnaryLimit_default_instance_;
}  // namespace v1
}  // namespace contract
}  // namespace api
}  // namespace invest
}  // namespace public_
}  // namespace tinkoff
PROTOBUF_NAMESPACE_OPEN
template<> ::tinkoff::public_::invest::api::contract::v1::Account* Arena::CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::Account>(Arena*);
template<> ::tinkoff::public_::invest::api::contract::v1::GetAccountsRequest* Arena::CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::GetAccountsRequest>(Arena*);
template<> ::tinkoff::public_::invest::api::contract::v1::GetAccountsResponse* Arena::CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::GetAccountsResponse>(Arena*);
template<> ::tinkoff::public_::invest::api::contract::v1::GetInfoRequest* Arena::CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::GetInfoRequest>(Arena*);
template<> ::tinkoff::public_::invest::api::contract::v1::GetInfoResponse* Arena::CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::GetInfoResponse>(Arena*);
template<> ::tinkoff::public_::invest::api::contract::v1::GetMarginAttributesRequest* Arena::CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::GetMarginAttributesRequest>(Arena*);
template<> ::tinkoff::public_::invest::api::contract::v1::GetMarginAttributesResponse* Arena::CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::GetMarginAttributesResponse>(Arena*);
template<> ::tinkoff::public_::invest::api::contract::v1::GetUserTariffRequest* Arena::CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::GetUserTariffRequest>(Arena*);
template<> ::tinkoff::public_::invest::api::contract::v1::GetUserTariffResponse* Arena::CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::GetUserTariffResponse>(Arena*);
template<> ::tinkoff::public_::invest::api::contract::v1::StreamLimit* Arena::CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::StreamLimit>(Arena*);
template<> ::tinkoff::public_::invest::api::contract::v1::UnaryLimit* Arena::CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::UnaryLimit>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tinkoff {
namespace public_ {
namespace invest {
namespace api {
namespace contract {
namespace v1 {

enum AccountType : int {
  ACCOUNT_TYPE_UNSPECIFIED = 0,
  ACCOUNT_TYPE_TINKOFF = 1,
  ACCOUNT_TYPE_TINKOFF_IIS = 2,
  ACCOUNT_TYPE_INVEST_BOX = 3,
  AccountType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AccountType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AccountType_IsValid(int value);
constexpr AccountType AccountType_MIN = ACCOUNT_TYPE_UNSPECIFIED;
constexpr AccountType AccountType_MAX = ACCOUNT_TYPE_INVEST_BOX;
constexpr int AccountType_ARRAYSIZE = AccountType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AccountType_descriptor();
template<typename T>
inline const std::string& AccountType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AccountType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AccountType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AccountType_descriptor(), enum_t_value);
}
inline bool AccountType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AccountType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AccountType>(
    AccountType_descriptor(), name, value);
}
enum AccountStatus : int {
  ACCOUNT_STATUS_UNSPECIFIED = 0,
  ACCOUNT_STATUS_NEW = 1,
  ACCOUNT_STATUS_OPEN = 2,
  ACCOUNT_STATUS_CLOSED = 3,
  AccountStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AccountStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AccountStatus_IsValid(int value);
constexpr AccountStatus AccountStatus_MIN = ACCOUNT_STATUS_UNSPECIFIED;
constexpr AccountStatus AccountStatus_MAX = ACCOUNT_STATUS_CLOSED;
constexpr int AccountStatus_ARRAYSIZE = AccountStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AccountStatus_descriptor();
template<typename T>
inline const std::string& AccountStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AccountStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AccountStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AccountStatus_descriptor(), enum_t_value);
}
inline bool AccountStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AccountStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AccountStatus>(
    AccountStatus_descriptor(), name, value);
}
enum AccessLevel : int {
  ACCOUNT_ACCESS_LEVEL_UNSPECIFIED = 0,
  ACCOUNT_ACCESS_LEVEL_FULL_ACCESS = 1,
  ACCOUNT_ACCESS_LEVEL_READ_ONLY = 2,
  ACCOUNT_ACCESS_LEVEL_NO_ACCESS = 3,
  AccessLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AccessLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AccessLevel_IsValid(int value);
constexpr AccessLevel AccessLevel_MIN = ACCOUNT_ACCESS_LEVEL_UNSPECIFIED;
constexpr AccessLevel AccessLevel_MAX = ACCOUNT_ACCESS_LEVEL_NO_ACCESS;
constexpr int AccessLevel_ARRAYSIZE = AccessLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AccessLevel_descriptor();
template<typename T>
inline const std::string& AccessLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AccessLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AccessLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AccessLevel_descriptor(), enum_t_value);
}
inline bool AccessLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AccessLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AccessLevel>(
    AccessLevel_descriptor(), name, value);
}
// ===================================================================

class GetAccountsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.GetAccountsRequest) */ {
 public:
  inline GetAccountsRequest() : GetAccountsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetAccountsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAccountsRequest(const GetAccountsRequest& from);
  GetAccountsRequest(GetAccountsRequest&& from) noexcept
    : GetAccountsRequest() {
    *this = ::std::move(from);
  }

  inline GetAccountsRequest& operator=(const GetAccountsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountsRequest& operator=(GetAccountsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccountsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAccountsRequest* internal_default_instance() {
    return reinterpret_cast<const GetAccountsRequest*>(
               &_GetAccountsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetAccountsRequest& a, GetAccountsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccountsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccountsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAccountsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAccountsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetAccountsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetAccountsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.GetAccountsRequest";
  }
  protected:
  explicit GetAccountsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.GetAccountsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_users_2eproto;
};
// -------------------------------------------------------------------

class GetAccountsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.GetAccountsResponse) */ {
 public:
  inline GetAccountsResponse() : GetAccountsResponse(nullptr) {}
  ~GetAccountsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetAccountsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAccountsResponse(const GetAccountsResponse& from);
  GetAccountsResponse(GetAccountsResponse&& from) noexcept
    : GetAccountsResponse() {
    *this = ::std::move(from);
  }

  inline GetAccountsResponse& operator=(const GetAccountsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountsResponse& operator=(GetAccountsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccountsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAccountsResponse* internal_default_instance() {
    return reinterpret_cast<const GetAccountsResponse*>(
               &_GetAccountsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetAccountsResponse& a, GetAccountsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccountsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccountsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAccountsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAccountsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAccountsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAccountsResponse& from) {
    GetAccountsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.GetAccountsResponse";
  }
  protected:
  explicit GetAccountsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountsFieldNumber = 1,
  };
  // repeated .tinkoff.public_.invest.api.contract.v1.Account accounts = 1;
  int accounts_size() const;
  private:
  int _internal_accounts_size() const;
  public:
  void clear_accounts();
  ::tinkoff::public_::invest::api::contract::v1::Account* mutable_accounts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::Account >*
      mutable_accounts();
  private:
  const ::tinkoff::public_::invest::api::contract::v1::Account& _internal_accounts(int index) const;
  ::tinkoff::public_::invest::api::contract::v1::Account* _internal_add_accounts();
  public:
  const ::tinkoff::public_::invest::api::contract::v1::Account& accounts(int index) const;
  ::tinkoff::public_::invest::api::contract::v1::Account* add_accounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::Account >&
      accounts() const;

  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.GetAccountsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::Account > accounts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_users_2eproto;
};
// -------------------------------------------------------------------

class Account final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.Account) */ {
 public:
  inline Account() : Account(nullptr) {}
  ~Account() override;
  explicit PROTOBUF_CONSTEXPR Account(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Account(const Account& from);
  Account(Account&& from) noexcept
    : Account() {
    *this = ::std::move(from);
  }

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }
  inline Account& operator=(Account&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Account& default_instance() {
    return *internal_default_instance();
  }
  static inline const Account* internal_default_instance() {
    return reinterpret_cast<const Account*>(
               &_Account_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Account& a, Account& b) {
    a.Swap(&b);
  }
  inline void Swap(Account* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Account* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Account* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Account>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Account& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Account& from) {
    Account::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Account* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.Account";
  }
  protected:
  explicit Account(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 3,
    kOpenedDateFieldNumber = 5,
    kClosedDateFieldNumber = 6,
    kTypeFieldNumber = 2,
    kStatusFieldNumber = 4,
    kAccessLevelFieldNumber = 7,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Timestamp opened_date = 5;
  bool has_opened_date() const;
  private:
  bool _internal_has_opened_date() const;
  public:
  void clear_opened_date();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& opened_date() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_opened_date();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_opened_date();
  void set_allocated_opened_date(::PROTOBUF_NAMESPACE_ID::Timestamp* opened_date);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_opened_date() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_opened_date();
  public:
  void unsafe_arena_set_allocated_opened_date(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* opened_date);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_opened_date();

  // .google.protobuf.Timestamp closed_date = 6;
  bool has_closed_date() const;
  private:
  bool _internal_has_closed_date() const;
  public:
  void clear_closed_date();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& closed_date() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_closed_date();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_closed_date();
  void set_allocated_closed_date(::PROTOBUF_NAMESPACE_ID::Timestamp* closed_date);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_closed_date() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_closed_date();
  public:
  void unsafe_arena_set_allocated_closed_date(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* closed_date);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_closed_date();

  // .tinkoff.public_.invest.api.contract.v1.AccountType type = 2;
  void clear_type();
  ::tinkoff::public_::invest::api::contract::v1::AccountType type() const;
  void set_type(::tinkoff::public_::invest::api::contract::v1::AccountType value);
  private:
  ::tinkoff::public_::invest::api::contract::v1::AccountType _internal_type() const;
  void _internal_set_type(::tinkoff::public_::invest::api::contract::v1::AccountType value);
  public:

  // .tinkoff.public_.invest.api.contract.v1.AccountStatus status = 4;
  void clear_status();
  ::tinkoff::public_::invest::api::contract::v1::AccountStatus status() const;
  void set_status(::tinkoff::public_::invest::api::contract::v1::AccountStatus value);
  private:
  ::tinkoff::public_::invest::api::contract::v1::AccountStatus _internal_status() const;
  void _internal_set_status(::tinkoff::public_::invest::api::contract::v1::AccountStatus value);
  public:

  // .tinkoff.public_.invest.api.contract.v1.AccessLevel access_level = 7;
  void clear_access_level();
  ::tinkoff::public_::invest::api::contract::v1::AccessLevel access_level() const;
  void set_access_level(::tinkoff::public_::invest::api::contract::v1::AccessLevel value);
  private:
  ::tinkoff::public_::invest::api::contract::v1::AccessLevel _internal_access_level() const;
  void _internal_set_access_level(::tinkoff::public_::invest::api::contract::v1::AccessLevel value);
  public:

  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.Account)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* opened_date_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* closed_date_;
    int type_;
    int status_;
    int access_level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_users_2eproto;
};
// -------------------------------------------------------------------

class GetMarginAttributesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesRequest) */ {
 public:
  inline GetMarginAttributesRequest() : GetMarginAttributesRequest(nullptr) {}
  ~GetMarginAttributesRequest() override;
  explicit PROTOBUF_CONSTEXPR GetMarginAttributesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMarginAttributesRequest(const GetMarginAttributesRequest& from);
  GetMarginAttributesRequest(GetMarginAttributesRequest&& from) noexcept
    : GetMarginAttributesRequest() {
    *this = ::std::move(from);
  }

  inline GetMarginAttributesRequest& operator=(const GetMarginAttributesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMarginAttributesRequest& operator=(GetMarginAttributesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMarginAttributesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMarginAttributesRequest* internal_default_instance() {
    return reinterpret_cast<const GetMarginAttributesRequest*>(
               &_GetMarginAttributesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetMarginAttributesRequest& a, GetMarginAttributesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMarginAttributesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMarginAttributesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMarginAttributesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMarginAttributesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMarginAttributesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMarginAttributesRequest& from) {
    GetMarginAttributesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMarginAttributesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.GetMarginAttributesRequest";
  }
  protected:
  explicit GetMarginAttributesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
  };
  // string account_id = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_users_2eproto;
};
// -------------------------------------------------------------------

class GetMarginAttributesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse) */ {
 public:
  inline GetMarginAttributesResponse() : GetMarginAttributesResponse(nullptr) {}
  ~GetMarginAttributesResponse() override;
  explicit PROTOBUF_CONSTEXPR GetMarginAttributesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMarginAttributesResponse(const GetMarginAttributesResponse& from);
  GetMarginAttributesResponse(GetMarginAttributesResponse&& from) noexcept
    : GetMarginAttributesResponse() {
    *this = ::std::move(from);
  }

  inline GetMarginAttributesResponse& operator=(const GetMarginAttributesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMarginAttributesResponse& operator=(GetMarginAttributesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMarginAttributesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMarginAttributesResponse* internal_default_instance() {
    return reinterpret_cast<const GetMarginAttributesResponse*>(
               &_GetMarginAttributesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetMarginAttributesResponse& a, GetMarginAttributesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMarginAttributesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMarginAttributesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMarginAttributesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMarginAttributesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMarginAttributesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMarginAttributesResponse& from) {
    GetMarginAttributesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMarginAttributesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse";
  }
  protected:
  explicit GetMarginAttributesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiquidPortfolioFieldNumber = 1,
    kStartingMarginFieldNumber = 2,
    kMinimalMarginFieldNumber = 3,
    kFundsSufficiencyLevelFieldNumber = 4,
    kAmountOfMissingFundsFieldNumber = 5,
    kCorrectedMarginFieldNumber = 6,
  };
  // .tinkoff.public_.invest.api.contract.v1.MoneyValue liquid_portfolio = 1;
  bool has_liquid_portfolio() const;
  private:
  bool _internal_has_liquid_portfolio() const;
  public:
  void clear_liquid_portfolio();
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& liquid_portfolio() const;
  PROTOBUF_NODISCARD ::tinkoff::public_::invest::api::contract::v1::MoneyValue* release_liquid_portfolio();
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* mutable_liquid_portfolio();
  void set_allocated_liquid_portfolio(::tinkoff::public_::invest::api::contract::v1::MoneyValue* liquid_portfolio);
  private:
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& _internal_liquid_portfolio() const;
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* _internal_mutable_liquid_portfolio();
  public:
  void unsafe_arena_set_allocated_liquid_portfolio(
      ::tinkoff::public_::invest::api::contract::v1::MoneyValue* liquid_portfolio);
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* unsafe_arena_release_liquid_portfolio();

  // .tinkoff.public_.invest.api.contract.v1.MoneyValue starting_margin = 2;
  bool has_starting_margin() const;
  private:
  bool _internal_has_starting_margin() const;
  public:
  void clear_starting_margin();
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& starting_margin() const;
  PROTOBUF_NODISCARD ::tinkoff::public_::invest::api::contract::v1::MoneyValue* release_starting_margin();
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* mutable_starting_margin();
  void set_allocated_starting_margin(::tinkoff::public_::invest::api::contract::v1::MoneyValue* starting_margin);
  private:
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& _internal_starting_margin() const;
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* _internal_mutable_starting_margin();
  public:
  void unsafe_arena_set_allocated_starting_margin(
      ::tinkoff::public_::invest::api::contract::v1::MoneyValue* starting_margin);
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* unsafe_arena_release_starting_margin();

  // .tinkoff.public_.invest.api.contract.v1.MoneyValue minimal_margin = 3;
  bool has_minimal_margin() const;
  private:
  bool _internal_has_minimal_margin() const;
  public:
  void clear_minimal_margin();
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& minimal_margin() const;
  PROTOBUF_NODISCARD ::tinkoff::public_::invest::api::contract::v1::MoneyValue* release_minimal_margin();
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* mutable_minimal_margin();
  void set_allocated_minimal_margin(::tinkoff::public_::invest::api::contract::v1::MoneyValue* minimal_margin);
  private:
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& _internal_minimal_margin() const;
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* _internal_mutable_minimal_margin();
  public:
  void unsafe_arena_set_allocated_minimal_margin(
      ::tinkoff::public_::invest::api::contract::v1::MoneyValue* minimal_margin);
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* unsafe_arena_release_minimal_margin();

  // .tinkoff.public_.invest.api.contract.v1.Quotation funds_sufficiency_level = 4;
  bool has_funds_sufficiency_level() const;
  private:
  bool _internal_has_funds_sufficiency_level() const;
  public:
  void clear_funds_sufficiency_level();
  const ::tinkoff::public_::invest::api::contract::v1::Quotation& funds_sufficiency_level() const;
  PROTOBUF_NODISCARD ::tinkoff::public_::invest::api::contract::v1::Quotation* release_funds_sufficiency_level();
  ::tinkoff::public_::invest::api::contract::v1::Quotation* mutable_funds_sufficiency_level();
  void set_allocated_funds_sufficiency_level(::tinkoff::public_::invest::api::contract::v1::Quotation* funds_sufficiency_level);
  private:
  const ::tinkoff::public_::invest::api::contract::v1::Quotation& _internal_funds_sufficiency_level() const;
  ::tinkoff::public_::invest::api::contract::v1::Quotation* _internal_mutable_funds_sufficiency_level();
  public:
  void unsafe_arena_set_allocated_funds_sufficiency_level(
      ::tinkoff::public_::invest::api::contract::v1::Quotation* funds_sufficiency_level);
  ::tinkoff::public_::invest::api::contract::v1::Quotation* unsafe_arena_release_funds_sufficiency_level();

  // .tinkoff.public_.invest.api.contract.v1.MoneyValue amount_of_missing_funds = 5;
  bool has_amount_of_missing_funds() const;
  private:
  bool _internal_has_amount_of_missing_funds() const;
  public:
  void clear_amount_of_missing_funds();
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& amount_of_missing_funds() const;
  PROTOBUF_NODISCARD ::tinkoff::public_::invest::api::contract::v1::MoneyValue* release_amount_of_missing_funds();
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* mutable_amount_of_missing_funds();
  void set_allocated_amount_of_missing_funds(::tinkoff::public_::invest::api::contract::v1::MoneyValue* amount_of_missing_funds);
  private:
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& _internal_amount_of_missing_funds() const;
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* _internal_mutable_amount_of_missing_funds();
  public:
  void unsafe_arena_set_allocated_amount_of_missing_funds(
      ::tinkoff::public_::invest::api::contract::v1::MoneyValue* amount_of_missing_funds);
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* unsafe_arena_release_amount_of_missing_funds();

  // .tinkoff.public_.invest.api.contract.v1.MoneyValue corrected_margin = 6;
  bool has_corrected_margin() const;
  private:
  bool _internal_has_corrected_margin() const;
  public:
  void clear_corrected_margin();
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& corrected_margin() const;
  PROTOBUF_NODISCARD ::tinkoff::public_::invest::api::contract::v1::MoneyValue* release_corrected_margin();
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* mutable_corrected_margin();
  void set_allocated_corrected_margin(::tinkoff::public_::invest::api::contract::v1::MoneyValue* corrected_margin);
  private:
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& _internal_corrected_margin() const;
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* _internal_mutable_corrected_margin();
  public:
  void unsafe_arena_set_allocated_corrected_margin(
      ::tinkoff::public_::invest::api::contract::v1::MoneyValue* corrected_margin);
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* unsafe_arena_release_corrected_margin();

  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::tinkoff::public_::invest::api::contract::v1::MoneyValue* liquid_portfolio_;
    ::tinkoff::public_::invest::api::contract::v1::MoneyValue* starting_margin_;
    ::tinkoff::public_::invest::api::contract::v1::MoneyValue* minimal_margin_;
    ::tinkoff::public_::invest::api::contract::v1::Quotation* funds_sufficiency_level_;
    ::tinkoff::public_::invest::api::contract::v1::MoneyValue* amount_of_missing_funds_;
    ::tinkoff::public_::invest::api::contract::v1::MoneyValue* corrected_margin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_users_2eproto;
};
// -------------------------------------------------------------------

class GetUserTariffRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.GetUserTariffRequest) */ {
 public:
  inline GetUserTariffRequest() : GetUserTariffRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetUserTariffRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserTariffRequest(const GetUserTariffRequest& from);
  GetUserTariffRequest(GetUserTariffRequest&& from) noexcept
    : GetUserTariffRequest() {
    *this = ::std::move(from);
  }

  inline GetUserTariffRequest& operator=(const GetUserTariffRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserTariffRequest& operator=(GetUserTariffRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserTariffRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserTariffRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserTariffRequest*>(
               &_GetUserTariffRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetUserTariffRequest& a, GetUserTariffRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserTariffRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserTariffRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserTariffRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserTariffRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetUserTariffRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetUserTariffRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.GetUserTariffRequest";
  }
  protected:
  explicit GetUserTariffRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.GetUserTariffRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_users_2eproto;
};
// -------------------------------------------------------------------

class GetUserTariffResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse) */ {
 public:
  inline GetUserTariffResponse() : GetUserTariffResponse(nullptr) {}
  ~GetUserTariffResponse() override;
  explicit PROTOBUF_CONSTEXPR GetUserTariffResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserTariffResponse(const GetUserTariffResponse& from);
  GetUserTariffResponse(GetUserTariffResponse&& from) noexcept
    : GetUserTariffResponse() {
    *this = ::std::move(from);
  }

  inline GetUserTariffResponse& operator=(const GetUserTariffResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserTariffResponse& operator=(GetUserTariffResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserTariffResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserTariffResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserTariffResponse*>(
               &_GetUserTariffResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetUserTariffResponse& a, GetUserTariffResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserTariffResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserTariffResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserTariffResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserTariffResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserTariffResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserTariffResponse& from) {
    GetUserTariffResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserTariffResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse";
  }
  protected:
  explicit GetUserTariffResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnaryLimitsFieldNumber = 1,
    kStreamLimitsFieldNumber = 2,
  };
  // repeated .tinkoff.public_.invest.api.contract.v1.UnaryLimit unary_limits = 1;
  int unary_limits_size() const;
  private:
  int _internal_unary_limits_size() const;
  public:
  void clear_unary_limits();
  ::tinkoff::public_::invest::api::contract::v1::UnaryLimit* mutable_unary_limits(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::UnaryLimit >*
      mutable_unary_limits();
  private:
  const ::tinkoff::public_::invest::api::contract::v1::UnaryLimit& _internal_unary_limits(int index) const;
  ::tinkoff::public_::invest::api::contract::v1::UnaryLimit* _internal_add_unary_limits();
  public:
  const ::tinkoff::public_::invest::api::contract::v1::UnaryLimit& unary_limits(int index) const;
  ::tinkoff::public_::invest::api::contract::v1::UnaryLimit* add_unary_limits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::UnaryLimit >&
      unary_limits() const;

  // repeated .tinkoff.public_.invest.api.contract.v1.StreamLimit stream_limits = 2;
  int stream_limits_size() const;
  private:
  int _internal_stream_limits_size() const;
  public:
  void clear_stream_limits();
  ::tinkoff::public_::invest::api::contract::v1::StreamLimit* mutable_stream_limits(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::StreamLimit >*
      mutable_stream_limits();
  private:
  const ::tinkoff::public_::invest::api::contract::v1::StreamLimit& _internal_stream_limits(int index) const;
  ::tinkoff::public_::invest::api::contract::v1::StreamLimit* _internal_add_stream_limits();
  public:
  const ::tinkoff::public_::invest::api::contract::v1::StreamLimit& stream_limits(int index) const;
  ::tinkoff::public_::invest::api::contract::v1::StreamLimit* add_stream_limits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::StreamLimit >&
      stream_limits() const;

  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::UnaryLimit > unary_limits_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::StreamLimit > stream_limits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_users_2eproto;
};
// -------------------------------------------------------------------

class UnaryLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.UnaryLimit) */ {
 public:
  inline UnaryLimit() : UnaryLimit(nullptr) {}
  ~UnaryLimit() override;
  explicit PROTOBUF_CONSTEXPR UnaryLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnaryLimit(const UnaryLimit& from);
  UnaryLimit(UnaryLimit&& from) noexcept
    : UnaryLimit() {
    *this = ::std::move(from);
  }

  inline UnaryLimit& operator=(const UnaryLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnaryLimit& operator=(UnaryLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnaryLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnaryLimit* internal_default_instance() {
    return reinterpret_cast<const UnaryLimit*>(
               &_UnaryLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UnaryLimit& a, UnaryLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(UnaryLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnaryLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnaryLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnaryLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnaryLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnaryLimit& from) {
    UnaryLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnaryLimit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.UnaryLimit";
  }
  protected:
  explicit UnaryLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMethodsFieldNumber = 2,
    kLimitPerMinuteFieldNumber = 1,
  };
  // repeated string methods = 2;
  int methods_size() const;
  private:
  int _internal_methods_size() const;
  public:
  void clear_methods();
  const std::string& methods(int index) const;
  std::string* mutable_methods(int index);
  void set_methods(int index, const std::string& value);
  void set_methods(int index, std::string&& value);
  void set_methods(int index, const char* value);
  void set_methods(int index, const char* value, size_t size);
  std::string* add_methods();
  void add_methods(const std::string& value);
  void add_methods(std::string&& value);
  void add_methods(const char* value);
  void add_methods(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& methods() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_methods();
  private:
  const std::string& _internal_methods(int index) const;
  std::string* _internal_add_methods();
  public:

  // int32 limit_per_minute = 1;
  void clear_limit_per_minute();
  int32_t limit_per_minute() const;
  void set_limit_per_minute(int32_t value);
  private:
  int32_t _internal_limit_per_minute() const;
  void _internal_set_limit_per_minute(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.UnaryLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> methods_;
    int32_t limit_per_minute_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_users_2eproto;
};
// -------------------------------------------------------------------

class StreamLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.StreamLimit) */ {
 public:
  inline StreamLimit() : StreamLimit(nullptr) {}
  ~StreamLimit() override;
  explicit PROTOBUF_CONSTEXPR StreamLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamLimit(const StreamLimit& from);
  StreamLimit(StreamLimit&& from) noexcept
    : StreamLimit() {
    *this = ::std::move(from);
  }

  inline StreamLimit& operator=(const StreamLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamLimit& operator=(StreamLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamLimit* internal_default_instance() {
    return reinterpret_cast<const StreamLimit*>(
               &_StreamLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StreamLimit& a, StreamLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamLimit& from) {
    StreamLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamLimit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.StreamLimit";
  }
  protected:
  explicit StreamLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamsFieldNumber = 2,
    kLimitFieldNumber = 1,
    kOpenFieldNumber = 3,
  };
  // repeated string streams = 2;
  int streams_size() const;
  private:
  int _internal_streams_size() const;
  public:
  void clear_streams();
  const std::string& streams(int index) const;
  std::string* mutable_streams(int index);
  void set_streams(int index, const std::string& value);
  void set_streams(int index, std::string&& value);
  void set_streams(int index, const char* value);
  void set_streams(int index, const char* value, size_t size);
  std::string* add_streams();
  void add_streams(const std::string& value);
  void add_streams(std::string&& value);
  void add_streams(const char* value);
  void add_streams(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& streams() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_streams();
  private:
  const std::string& _internal_streams(int index) const;
  std::string* _internal_add_streams();
  public:

  // int32 limit = 1;
  void clear_limit();
  int32_t limit() const;
  void set_limit(int32_t value);
  private:
  int32_t _internal_limit() const;
  void _internal_set_limit(int32_t value);
  public:

  // int32 open = 3;
  void clear_open();
  int32_t open() const;
  void set_open(int32_t value);
  private:
  int32_t _internal_open() const;
  void _internal_set_open(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.StreamLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> streams_;
    int32_t limit_;
    int32_t open_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_users_2eproto;
};
// -------------------------------------------------------------------

class GetInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.GetInfoRequest) */ {
 public:
  inline GetInfoRequest() : GetInfoRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetInfoRequest(const GetInfoRequest& from);
  GetInfoRequest(GetInfoRequest&& from) noexcept
    : GetInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetInfoRequest& operator=(const GetInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetInfoRequest& operator=(GetInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetInfoRequest*>(
               &_GetInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetInfoRequest& a, GetInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.GetInfoRequest";
  }
  protected:
  explicit GetInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.GetInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_users_2eproto;
};
// -------------------------------------------------------------------

class GetInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.GetInfoResponse) */ {
 public:
  inline GetInfoResponse() : GetInfoResponse(nullptr) {}
  ~GetInfoResponse() override;
  explicit PROTOBUF_CONSTEXPR GetInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetInfoResponse(const GetInfoResponse& from);
  GetInfoResponse(GetInfoResponse&& from) noexcept
    : GetInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetInfoResponse& operator=(const GetInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetInfoResponse& operator=(GetInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetInfoResponse*>(
               &_GetInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetInfoResponse& a, GetInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetInfoResponse& from) {
    GetInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.GetInfoResponse";
  }
  protected:
  explicit GetInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQualifiedForWorkWithFieldNumber = 3,
    kTariffFieldNumber = 4,
    kPremStatusFieldNumber = 1,
    kQualStatusFieldNumber = 2,
  };
  // repeated string qualified_for_work_with = 3;
  int qualified_for_work_with_size() const;
  private:
  int _internal_qualified_for_work_with_size() const;
  public:
  void clear_qualified_for_work_with();
  const std::string& qualified_for_work_with(int index) const;
  std::string* mutable_qualified_for_work_with(int index);
  void set_qualified_for_work_with(int index, const std::string& value);
  void set_qualified_for_work_with(int index, std::string&& value);
  void set_qualified_for_work_with(int index, const char* value);
  void set_qualified_for_work_with(int index, const char* value, size_t size);
  std::string* add_qualified_for_work_with();
  void add_qualified_for_work_with(const std::string& value);
  void add_qualified_for_work_with(std::string&& value);
  void add_qualified_for_work_with(const char* value);
  void add_qualified_for_work_with(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& qualified_for_work_with() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_qualified_for_work_with();
  private:
  const std::string& _internal_qualified_for_work_with(int index) const;
  std::string* _internal_add_qualified_for_work_with();
  public:

  // string tariff = 4;
  void clear_tariff();
  const std::string& tariff() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tariff(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tariff();
  PROTOBUF_NODISCARD std::string* release_tariff();
  void set_allocated_tariff(std::string* tariff);
  private:
  const std::string& _internal_tariff() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tariff(const std::string& value);
  std::string* _internal_mutable_tariff();
  public:

  // bool prem_status = 1;
  void clear_prem_status();
  bool prem_status() const;
  void set_prem_status(bool value);
  private:
  bool _internal_prem_status() const;
  void _internal_set_prem_status(bool value);
  public:

  // bool qual_status = 2;
  void clear_qual_status();
  bool qual_status() const;
  void set_qual_status(bool value);
  private:
  bool _internal_qual_status() const;
  void _internal_set_qual_status(bool value);
  public:

  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.GetInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> qualified_for_work_with_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tariff_;
    bool prem_status_;
    bool qual_status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_users_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetAccountsRequest

// -------------------------------------------------------------------

// GetAccountsResponse

// repeated .tinkoff.public_.invest.api.contract.v1.Account accounts = 1;
inline int GetAccountsResponse::_internal_accounts_size() const {
  return _impl_.accounts_.size();
}
inline int GetAccountsResponse::accounts_size() const {
  return _internal_accounts_size();
}
inline void GetAccountsResponse::clear_accounts() {
  _impl_.accounts_.Clear();
}
inline ::tinkoff::public_::invest::api::contract::v1::Account* GetAccountsResponse::mutable_accounts(int index) {
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetAccountsResponse.accounts)
  return _impl_.accounts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::Account >*
GetAccountsResponse::mutable_accounts() {
  // @@protoc_insertion_point(field_mutable_list:tinkoff.public_.invest.api.contract.v1.GetAccountsResponse.accounts)
  return &_impl_.accounts_;
}
inline const ::tinkoff::public_::invest::api::contract::v1::Account& GetAccountsResponse::_internal_accounts(int index) const {
  return _impl_.accounts_.Get(index);
}
inline const ::tinkoff::public_::invest::api::contract::v1::Account& GetAccountsResponse::accounts(int index) const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetAccountsResponse.accounts)
  return _internal_accounts(index);
}
inline ::tinkoff::public_::invest::api::contract::v1::Account* GetAccountsResponse::_internal_add_accounts() {
  return _impl_.accounts_.Add();
}
inline ::tinkoff::public_::invest::api::contract::v1::Account* GetAccountsResponse::add_accounts() {
  ::tinkoff::public_::invest::api::contract::v1::Account* _add = _internal_add_accounts();
  // @@protoc_insertion_point(field_add:tinkoff.public_.invest.api.contract.v1.GetAccountsResponse.accounts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::Account >&
GetAccountsResponse::accounts() const {
  // @@protoc_insertion_point(field_list:tinkoff.public_.invest.api.contract.v1.GetAccountsResponse.accounts)
  return _impl_.accounts_;
}

// -------------------------------------------------------------------

// Account

// string id = 1;
inline void Account::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Account::id() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.Account.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Account::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.Account.id)
}
inline std::string* Account::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.Account.id)
  return _s;
}
inline const std::string& Account::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Account::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Account::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Account::release_id() {
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.Account.id)
  return _impl_.id_.Release();
}
inline void Account::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.Account.id)
}

// .tinkoff.public_.invest.api.contract.v1.AccountType type = 2;
inline void Account::clear_type() {
  _impl_.type_ = 0;
}
inline ::tinkoff::public_::invest::api::contract::v1::AccountType Account::_internal_type() const {
  return static_cast< ::tinkoff::public_::invest::api::contract::v1::AccountType >(_impl_.type_);
}
inline ::tinkoff::public_::invest::api::contract::v1::AccountType Account::type() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.Account.type)
  return _internal_type();
}
inline void Account::_internal_set_type(::tinkoff::public_::invest::api::contract::v1::AccountType value) {
  
  _impl_.type_ = value;
}
inline void Account::set_type(::tinkoff::public_::invest::api::contract::v1::AccountType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.Account.type)
}

// string name = 3;
inline void Account::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Account::name() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.Account.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Account::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.Account.name)
}
inline std::string* Account::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.Account.name)
  return _s;
}
inline const std::string& Account::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Account::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Account::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Account::release_name() {
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.Account.name)
  return _impl_.name_.Release();
}
inline void Account::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.Account.name)
}

// .tinkoff.public_.invest.api.contract.v1.AccountStatus status = 4;
inline void Account::clear_status() {
  _impl_.status_ = 0;
}
inline ::tinkoff::public_::invest::api::contract::v1::AccountStatus Account::_internal_status() const {
  return static_cast< ::tinkoff::public_::invest::api::contract::v1::AccountStatus >(_impl_.status_);
}
inline ::tinkoff::public_::invest::api::contract::v1::AccountStatus Account::status() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.Account.status)
  return _internal_status();
}
inline void Account::_internal_set_status(::tinkoff::public_::invest::api::contract::v1::AccountStatus value) {
  
  _impl_.status_ = value;
}
inline void Account::set_status(::tinkoff::public_::invest::api::contract::v1::AccountStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.Account.status)
}

// .google.protobuf.Timestamp opened_date = 5;
inline bool Account::_internal_has_opened_date() const {
  return this != internal_default_instance() && _impl_.opened_date_ != nullptr;
}
inline bool Account::has_opened_date() const {
  return _internal_has_opened_date();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Account::_internal_opened_date() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.opened_date_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Account::opened_date() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.Account.opened_date)
  return _internal_opened_date();
}
inline void Account::unsafe_arena_set_allocated_opened_date(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* opened_date) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.opened_date_);
  }
  _impl_.opened_date_ = opened_date;
  if (opened_date) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tinkoff.public_.invest.api.contract.v1.Account.opened_date)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Account::release_opened_date() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.opened_date_;
  _impl_.opened_date_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Account::unsafe_arena_release_opened_date() {
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.Account.opened_date)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.opened_date_;
  _impl_.opened_date_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Account::_internal_mutable_opened_date() {
  
  if (_impl_.opened_date_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.opened_date_ = p;
  }
  return _impl_.opened_date_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Account::mutable_opened_date() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_opened_date();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.Account.opened_date)
  return _msg;
}
inline void Account::set_allocated_opened_date(::PROTOBUF_NAMESPACE_ID::Timestamp* opened_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.opened_date_);
  }
  if (opened_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(opened_date));
    if (message_arena != submessage_arena) {
      opened_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opened_date, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.opened_date_ = opened_date;
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.Account.opened_date)
}

// .google.protobuf.Timestamp closed_date = 6;
inline bool Account::_internal_has_closed_date() const {
  return this != internal_default_instance() && _impl_.closed_date_ != nullptr;
}
inline bool Account::has_closed_date() const {
  return _internal_has_closed_date();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Account::_internal_closed_date() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.closed_date_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Account::closed_date() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.Account.closed_date)
  return _internal_closed_date();
}
inline void Account::unsafe_arena_set_allocated_closed_date(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* closed_date) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.closed_date_);
  }
  _impl_.closed_date_ = closed_date;
  if (closed_date) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tinkoff.public_.invest.api.contract.v1.Account.closed_date)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Account::release_closed_date() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.closed_date_;
  _impl_.closed_date_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Account::unsafe_arena_release_closed_date() {
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.Account.closed_date)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.closed_date_;
  _impl_.closed_date_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Account::_internal_mutable_closed_date() {
  
  if (_impl_.closed_date_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.closed_date_ = p;
  }
  return _impl_.closed_date_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Account::mutable_closed_date() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_closed_date();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.Account.closed_date)
  return _msg;
}
inline void Account::set_allocated_closed_date(::PROTOBUF_NAMESPACE_ID::Timestamp* closed_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.closed_date_);
  }
  if (closed_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(closed_date));
    if (message_arena != submessage_arena) {
      closed_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, closed_date, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.closed_date_ = closed_date;
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.Account.closed_date)
}

// .tinkoff.public_.invest.api.contract.v1.AccessLevel access_level = 7;
inline void Account::clear_access_level() {
  _impl_.access_level_ = 0;
}
inline ::tinkoff::public_::invest::api::contract::v1::AccessLevel Account::_internal_access_level() const {
  return static_cast< ::tinkoff::public_::invest::api::contract::v1::AccessLevel >(_impl_.access_level_);
}
inline ::tinkoff::public_::invest::api::contract::v1::AccessLevel Account::access_level() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.Account.access_level)
  return _internal_access_level();
}
inline void Account::_internal_set_access_level(::tinkoff::public_::invest::api::contract::v1::AccessLevel value) {
  
  _impl_.access_level_ = value;
}
inline void Account::set_access_level(::tinkoff::public_::invest::api::contract::v1::AccessLevel value) {
  _internal_set_access_level(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.Account.access_level)
}

// -------------------------------------------------------------------

// GetMarginAttributesRequest

// string account_id = 1 [(.google.api.field_behavior) = REQUIRED];
inline void GetMarginAttributesRequest::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& GetMarginAttributesRequest::account_id() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesRequest.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetMarginAttributesRequest::set_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesRequest.account_id)
}
inline std::string* GetMarginAttributesRequest::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesRequest.account_id)
  return _s;
}
inline const std::string& GetMarginAttributesRequest::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void GetMarginAttributesRequest::_internal_set_account_id(const std::string& value) {
  
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetMarginAttributesRequest::_internal_mutable_account_id() {
  
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetMarginAttributesRequest::release_account_id() {
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesRequest.account_id)
  return _impl_.account_id_.Release();
}
inline void GetMarginAttributesRequest::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesRequest.account_id)
}

// -------------------------------------------------------------------

// GetMarginAttributesResponse

// .tinkoff.public_.invest.api.contract.v1.MoneyValue liquid_portfolio = 1;
inline bool GetMarginAttributesResponse::_internal_has_liquid_portfolio() const {
  return this != internal_default_instance() && _impl_.liquid_portfolio_ != nullptr;
}
inline bool GetMarginAttributesResponse::has_liquid_portfolio() const {
  return _internal_has_liquid_portfolio();
}
inline const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& GetMarginAttributesResponse::_internal_liquid_portfolio() const {
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue* p = _impl_.liquid_portfolio_;
  return p != nullptr ? *p : reinterpret_cast<const ::tinkoff::public_::invest::api::contract::v1::MoneyValue&>(
      ::tinkoff::public_::invest::api::contract::v1::_MoneyValue_default_instance_);
}
inline const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& GetMarginAttributesResponse::liquid_portfolio() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.liquid_portfolio)
  return _internal_liquid_portfolio();
}
inline void GetMarginAttributesResponse::unsafe_arena_set_allocated_liquid_portfolio(
    ::tinkoff::public_::invest::api::contract::v1::MoneyValue* liquid_portfolio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.liquid_portfolio_);
  }
  _impl_.liquid_portfolio_ = liquid_portfolio;
  if (liquid_portfolio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.liquid_portfolio)
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::release_liquid_portfolio() {
  
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* temp = _impl_.liquid_portfolio_;
  _impl_.liquid_portfolio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::unsafe_arena_release_liquid_portfolio() {
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.liquid_portfolio)
  
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* temp = _impl_.liquid_portfolio_;
  _impl_.liquid_portfolio_ = nullptr;
  return temp;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::_internal_mutable_liquid_portfolio() {
  
  if (_impl_.liquid_portfolio_ == nullptr) {
    auto* p = CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::MoneyValue>(GetArenaForAllocation());
    _impl_.liquid_portfolio_ = p;
  }
  return _impl_.liquid_portfolio_;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::mutable_liquid_portfolio() {
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* _msg = _internal_mutable_liquid_portfolio();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.liquid_portfolio)
  return _msg;
}
inline void GetMarginAttributesResponse::set_allocated_liquid_portfolio(::tinkoff::public_::invest::api::contract::v1::MoneyValue* liquid_portfolio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.liquid_portfolio_);
  }
  if (liquid_portfolio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(liquid_portfolio));
    if (message_arena != submessage_arena) {
      liquid_portfolio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, liquid_portfolio, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.liquid_portfolio_ = liquid_portfolio;
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.liquid_portfolio)
}

// .tinkoff.public_.invest.api.contract.v1.MoneyValue starting_margin = 2;
inline bool GetMarginAttributesResponse::_internal_has_starting_margin() const {
  return this != internal_default_instance() && _impl_.starting_margin_ != nullptr;
}
inline bool GetMarginAttributesResponse::has_starting_margin() const {
  return _internal_has_starting_margin();
}
inline const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& GetMarginAttributesResponse::_internal_starting_margin() const {
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue* p = _impl_.starting_margin_;
  return p != nullptr ? *p : reinterpret_cast<const ::tinkoff::public_::invest::api::contract::v1::MoneyValue&>(
      ::tinkoff::public_::invest::api::contract::v1::_MoneyValue_default_instance_);
}
inline const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& GetMarginAttributesResponse::starting_margin() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.starting_margin)
  return _internal_starting_margin();
}
inline void GetMarginAttributesResponse::unsafe_arena_set_allocated_starting_margin(
    ::tinkoff::public_::invest::api::contract::v1::MoneyValue* starting_margin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.starting_margin_);
  }
  _impl_.starting_margin_ = starting_margin;
  if (starting_margin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.starting_margin)
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::release_starting_margin() {
  
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* temp = _impl_.starting_margin_;
  _impl_.starting_margin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::unsafe_arena_release_starting_margin() {
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.starting_margin)
  
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* temp = _impl_.starting_margin_;
  _impl_.starting_margin_ = nullptr;
  return temp;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::_internal_mutable_starting_margin() {
  
  if (_impl_.starting_margin_ == nullptr) {
    auto* p = CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::MoneyValue>(GetArenaForAllocation());
    _impl_.starting_margin_ = p;
  }
  return _impl_.starting_margin_;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::mutable_starting_margin() {
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* _msg = _internal_mutable_starting_margin();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.starting_margin)
  return _msg;
}
inline void GetMarginAttributesResponse::set_allocated_starting_margin(::tinkoff::public_::invest::api::contract::v1::MoneyValue* starting_margin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.starting_margin_);
  }
  if (starting_margin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starting_margin));
    if (message_arena != submessage_arena) {
      starting_margin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, starting_margin, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.starting_margin_ = starting_margin;
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.starting_margin)
}

// .tinkoff.public_.invest.api.contract.v1.MoneyValue minimal_margin = 3;
inline bool GetMarginAttributesResponse::_internal_has_minimal_margin() const {
  return this != internal_default_instance() && _impl_.minimal_margin_ != nullptr;
}
inline bool GetMarginAttributesResponse::has_minimal_margin() const {
  return _internal_has_minimal_margin();
}
inline const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& GetMarginAttributesResponse::_internal_minimal_margin() const {
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue* p = _impl_.minimal_margin_;
  return p != nullptr ? *p : reinterpret_cast<const ::tinkoff::public_::invest::api::contract::v1::MoneyValue&>(
      ::tinkoff::public_::invest::api::contract::v1::_MoneyValue_default_instance_);
}
inline const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& GetMarginAttributesResponse::minimal_margin() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.minimal_margin)
  return _internal_minimal_margin();
}
inline void GetMarginAttributesResponse::unsafe_arena_set_allocated_minimal_margin(
    ::tinkoff::public_::invest::api::contract::v1::MoneyValue* minimal_margin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.minimal_margin_);
  }
  _impl_.minimal_margin_ = minimal_margin;
  if (minimal_margin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.minimal_margin)
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::release_minimal_margin() {
  
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* temp = _impl_.minimal_margin_;
  _impl_.minimal_margin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::unsafe_arena_release_minimal_margin() {
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.minimal_margin)
  
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* temp = _impl_.minimal_margin_;
  _impl_.minimal_margin_ = nullptr;
  return temp;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::_internal_mutable_minimal_margin() {
  
  if (_impl_.minimal_margin_ == nullptr) {
    auto* p = CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::MoneyValue>(GetArenaForAllocation());
    _impl_.minimal_margin_ = p;
  }
  return _impl_.minimal_margin_;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::mutable_minimal_margin() {
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* _msg = _internal_mutable_minimal_margin();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.minimal_margin)
  return _msg;
}
inline void GetMarginAttributesResponse::set_allocated_minimal_margin(::tinkoff::public_::invest::api::contract::v1::MoneyValue* minimal_margin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.minimal_margin_);
  }
  if (minimal_margin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(minimal_margin));
    if (message_arena != submessage_arena) {
      minimal_margin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, minimal_margin, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.minimal_margin_ = minimal_margin;
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.minimal_margin)
}

// .tinkoff.public_.invest.api.contract.v1.Quotation funds_sufficiency_level = 4;
inline bool GetMarginAttributesResponse::_internal_has_funds_sufficiency_level() const {
  return this != internal_default_instance() && _impl_.funds_sufficiency_level_ != nullptr;
}
inline bool GetMarginAttributesResponse::has_funds_sufficiency_level() const {
  return _internal_has_funds_sufficiency_level();
}
inline const ::tinkoff::public_::invest::api::contract::v1::Quotation& GetMarginAttributesResponse::_internal_funds_sufficiency_level() const {
  const ::tinkoff::public_::invest::api::contract::v1::Quotation* p = _impl_.funds_sufficiency_level_;
  return p != nullptr ? *p : reinterpret_cast<const ::tinkoff::public_::invest::api::contract::v1::Quotation&>(
      ::tinkoff::public_::invest::api::contract::v1::_Quotation_default_instance_);
}
inline const ::tinkoff::public_::invest::api::contract::v1::Quotation& GetMarginAttributesResponse::funds_sufficiency_level() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.funds_sufficiency_level)
  return _internal_funds_sufficiency_level();
}
inline void GetMarginAttributesResponse::unsafe_arena_set_allocated_funds_sufficiency_level(
    ::tinkoff::public_::invest::api::contract::v1::Quotation* funds_sufficiency_level) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.funds_sufficiency_level_);
  }
  _impl_.funds_sufficiency_level_ = funds_sufficiency_level;
  if (funds_sufficiency_level) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.funds_sufficiency_level)
}
inline ::tinkoff::public_::invest::api::contract::v1::Quotation* GetMarginAttributesResponse::release_funds_sufficiency_level() {
  
  ::tinkoff::public_::invest::api::contract::v1::Quotation* temp = _impl_.funds_sufficiency_level_;
  _impl_.funds_sufficiency_level_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tinkoff::public_::invest::api::contract::v1::Quotation* GetMarginAttributesResponse::unsafe_arena_release_funds_sufficiency_level() {
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.funds_sufficiency_level)
  
  ::tinkoff::public_::invest::api::contract::v1::Quotation* temp = _impl_.funds_sufficiency_level_;
  _impl_.funds_sufficiency_level_ = nullptr;
  return temp;
}
inline ::tinkoff::public_::invest::api::contract::v1::Quotation* GetMarginAttributesResponse::_internal_mutable_funds_sufficiency_level() {
  
  if (_impl_.funds_sufficiency_level_ == nullptr) {
    auto* p = CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::Quotation>(GetArenaForAllocation());
    _impl_.funds_sufficiency_level_ = p;
  }
  return _impl_.funds_sufficiency_level_;
}
inline ::tinkoff::public_::invest::api::contract::v1::Quotation* GetMarginAttributesResponse::mutable_funds_sufficiency_level() {
  ::tinkoff::public_::invest::api::contract::v1::Quotation* _msg = _internal_mutable_funds_sufficiency_level();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.funds_sufficiency_level)
  return _msg;
}
inline void GetMarginAttributesResponse::set_allocated_funds_sufficiency_level(::tinkoff::public_::invest::api::contract::v1::Quotation* funds_sufficiency_level) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.funds_sufficiency_level_);
  }
  if (funds_sufficiency_level) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(funds_sufficiency_level));
    if (message_arena != submessage_arena) {
      funds_sufficiency_level = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, funds_sufficiency_level, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.funds_sufficiency_level_ = funds_sufficiency_level;
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.funds_sufficiency_level)
}

// .tinkoff.public_.invest.api.contract.v1.MoneyValue amount_of_missing_funds = 5;
inline bool GetMarginAttributesResponse::_internal_has_amount_of_missing_funds() const {
  return this != internal_default_instance() && _impl_.amount_of_missing_funds_ != nullptr;
}
inline bool GetMarginAttributesResponse::has_amount_of_missing_funds() const {
  return _internal_has_amount_of_missing_funds();
}
inline const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& GetMarginAttributesResponse::_internal_amount_of_missing_funds() const {
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue* p = _impl_.amount_of_missing_funds_;
  return p != nullptr ? *p : reinterpret_cast<const ::tinkoff::public_::invest::api::contract::v1::MoneyValue&>(
      ::tinkoff::public_::invest::api::contract::v1::_MoneyValue_default_instance_);
}
inline const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& GetMarginAttributesResponse::amount_of_missing_funds() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.amount_of_missing_funds)
  return _internal_amount_of_missing_funds();
}
inline void GetMarginAttributesResponse::unsafe_arena_set_allocated_amount_of_missing_funds(
    ::tinkoff::public_::invest::api::contract::v1::MoneyValue* amount_of_missing_funds) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_of_missing_funds_);
  }
  _impl_.amount_of_missing_funds_ = amount_of_missing_funds;
  if (amount_of_missing_funds) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.amount_of_missing_funds)
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::release_amount_of_missing_funds() {
  
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* temp = _impl_.amount_of_missing_funds_;
  _impl_.amount_of_missing_funds_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::unsafe_arena_release_amount_of_missing_funds() {
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.amount_of_missing_funds)
  
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* temp = _impl_.amount_of_missing_funds_;
  _impl_.amount_of_missing_funds_ = nullptr;
  return temp;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::_internal_mutable_amount_of_missing_funds() {
  
  if (_impl_.amount_of_missing_funds_ == nullptr) {
    auto* p = CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::MoneyValue>(GetArenaForAllocation());
    _impl_.amount_of_missing_funds_ = p;
  }
  return _impl_.amount_of_missing_funds_;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::mutable_amount_of_missing_funds() {
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* _msg = _internal_mutable_amount_of_missing_funds();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.amount_of_missing_funds)
  return _msg;
}
inline void GetMarginAttributesResponse::set_allocated_amount_of_missing_funds(::tinkoff::public_::invest::api::contract::v1::MoneyValue* amount_of_missing_funds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_of_missing_funds_);
  }
  if (amount_of_missing_funds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amount_of_missing_funds));
    if (message_arena != submessage_arena) {
      amount_of_missing_funds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount_of_missing_funds, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.amount_of_missing_funds_ = amount_of_missing_funds;
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.amount_of_missing_funds)
}

// .tinkoff.public_.invest.api.contract.v1.MoneyValue corrected_margin = 6;
inline bool GetMarginAttributesResponse::_internal_has_corrected_margin() const {
  return this != internal_default_instance() && _impl_.corrected_margin_ != nullptr;
}
inline bool GetMarginAttributesResponse::has_corrected_margin() const {
  return _internal_has_corrected_margin();
}
inline const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& GetMarginAttributesResponse::_internal_corrected_margin() const {
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue* p = _impl_.corrected_margin_;
  return p != nullptr ? *p : reinterpret_cast<const ::tinkoff::public_::invest::api::contract::v1::MoneyValue&>(
      ::tinkoff::public_::invest::api::contract::v1::_MoneyValue_default_instance_);
}
inline const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& GetMarginAttributesResponse::corrected_margin() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.corrected_margin)
  return _internal_corrected_margin();
}
inline void GetMarginAttributesResponse::unsafe_arena_set_allocated_corrected_margin(
    ::tinkoff::public_::invest::api::contract::v1::MoneyValue* corrected_margin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.corrected_margin_);
  }
  _impl_.corrected_margin_ = corrected_margin;
  if (corrected_margin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.corrected_margin)
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::release_corrected_margin() {
  
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* temp = _impl_.corrected_margin_;
  _impl_.corrected_margin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::unsafe_arena_release_corrected_margin() {
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.corrected_margin)
  
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* temp = _impl_.corrected_margin_;
  _impl_.corrected_margin_ = nullptr;
  return temp;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::_internal_mutable_corrected_margin() {
  
  if (_impl_.corrected_margin_ == nullptr) {
    auto* p = CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::MoneyValue>(GetArenaForAllocation());
    _impl_.corrected_margin_ = p;
  }
  return _impl_.corrected_margin_;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::mutable_corrected_margin() {
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* _msg = _internal_mutable_corrected_margin();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.corrected_margin)
  return _msg;
}
inline void GetMarginAttributesResponse::set_allocated_corrected_margin(::tinkoff::public_::invest::api::contract::v1::MoneyValue* corrected_margin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.corrected_margin_);
  }
  if (corrected_margin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(corrected_margin));
    if (message_arena != submessage_arena) {
      corrected_margin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, corrected_margin, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.corrected_margin_ = corrected_margin;
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.corrected_margin)
}

// -------------------------------------------------------------------

// GetUserTariffRequest

// -------------------------------------------------------------------

// GetUserTariffResponse

// repeated .tinkoff.public_.invest.api.contract.v1.UnaryLimit unary_limits = 1;
inline int GetUserTariffResponse::_internal_unary_limits_size() const {
  return _impl_.unary_limits_.size();
}
inline int GetUserTariffResponse::unary_limits_size() const {
  return _internal_unary_limits_size();
}
inline void GetUserTariffResponse::clear_unary_limits() {
  _impl_.unary_limits_.Clear();
}
inline ::tinkoff::public_::invest::api::contract::v1::UnaryLimit* GetUserTariffResponse::mutable_unary_limits(int index) {
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse.unary_limits)
  return _impl_.unary_limits_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::UnaryLimit >*
GetUserTariffResponse::mutable_unary_limits() {
  // @@protoc_insertion_point(field_mutable_list:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse.unary_limits)
  return &_impl_.unary_limits_;
}
inline const ::tinkoff::public_::invest::api::contract::v1::UnaryLimit& GetUserTariffResponse::_internal_unary_limits(int index) const {
  return _impl_.unary_limits_.Get(index);
}
inline const ::tinkoff::public_::invest::api::contract::v1::UnaryLimit& GetUserTariffResponse::unary_limits(int index) const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse.unary_limits)
  return _internal_unary_limits(index);
}
inline ::tinkoff::public_::invest::api::contract::v1::UnaryLimit* GetUserTariffResponse::_internal_add_unary_limits() {
  return _impl_.unary_limits_.Add();
}
inline ::tinkoff::public_::invest::api::contract::v1::UnaryLimit* GetUserTariffResponse::add_unary_limits() {
  ::tinkoff::public_::invest::api::contract::v1::UnaryLimit* _add = _internal_add_unary_limits();
  // @@protoc_insertion_point(field_add:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse.unary_limits)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::UnaryLimit >&
GetUserTariffResponse::unary_limits() const {
  // @@protoc_insertion_point(field_list:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse.unary_limits)
  return _impl_.unary_limits_;
}

// repeated .tinkoff.public_.invest.api.contract.v1.StreamLimit stream_limits = 2;
inline int GetUserTariffResponse::_internal_stream_limits_size() const {
  return _impl_.stream_limits_.size();
}
inline int GetUserTariffResponse::stream_limits_size() const {
  return _internal_stream_limits_size();
}
inline void GetUserTariffResponse::clear_stream_limits() {
  _impl_.stream_limits_.Clear();
}
inline ::tinkoff::public_::invest::api::contract::v1::StreamLimit* GetUserTariffResponse::mutable_stream_limits(int index) {
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse.stream_limits)
  return _impl_.stream_limits_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::StreamLimit >*
GetUserTariffResponse::mutable_stream_limits() {
  // @@protoc_insertion_point(field_mutable_list:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse.stream_limits)
  return &_impl_.stream_limits_;
}
inline const ::tinkoff::public_::invest::api::contract::v1::StreamLimit& GetUserTariffResponse::_internal_stream_limits(int index) const {
  return _impl_.stream_limits_.Get(index);
}
inline const ::tinkoff::public_::invest::api::contract::v1::StreamLimit& GetUserTariffResponse::stream_limits(int index) const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse.stream_limits)
  return _internal_stream_limits(index);
}
inline ::tinkoff::public_::invest::api::contract::v1::StreamLimit* GetUserTariffResponse::_internal_add_stream_limits() {
  return _impl_.stream_limits_.Add();
}
inline ::tinkoff::public_::invest::api::contract::v1::StreamLimit* GetUserTariffResponse::add_stream_limits() {
  ::tinkoff::public_::invest::api::contract::v1::StreamLimit* _add = _internal_add_stream_limits();
  // @@protoc_insertion_point(field_add:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse.stream_limits)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::StreamLimit >&
GetUserTariffResponse::stream_limits() const {
  // @@protoc_insertion_point(field_list:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse.stream_limits)
  return _impl_.stream_limits_;
}

// -------------------------------------------------------------------

// UnaryLimit

// int32 limit_per_minute = 1;
inline void UnaryLimit::clear_limit_per_minute() {
  _impl_.limit_per_minute_ = 0;
}
inline int32_t UnaryLimit::_internal_limit_per_minute() const {
  return _impl_.limit_per_minute_;
}
inline int32_t UnaryLimit::limit_per_minute() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.UnaryLimit.limit_per_minute)
  return _internal_limit_per_minute();
}
inline void UnaryLimit::_internal_set_limit_per_minute(int32_t value) {
  
  _impl_.limit_per_minute_ = value;
}
inline void UnaryLimit::set_limit_per_minute(int32_t value) {
  _internal_set_limit_per_minute(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.UnaryLimit.limit_per_minute)
}

// repeated string methods = 2;
inline int UnaryLimit::_internal_methods_size() const {
  return _impl_.methods_.size();
}
inline int UnaryLimit::methods_size() const {
  return _internal_methods_size();
}
inline void UnaryLimit::clear_methods() {
  _impl_.methods_.Clear();
}
inline std::string* UnaryLimit::add_methods() {
  std::string* _s = _internal_add_methods();
  // @@protoc_insertion_point(field_add_mutable:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
  return _s;
}
inline const std::string& UnaryLimit::_internal_methods(int index) const {
  return _impl_.methods_.Get(index);
}
inline const std::string& UnaryLimit::methods(int index) const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
  return _internal_methods(index);
}
inline std::string* UnaryLimit::mutable_methods(int index) {
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
  return _impl_.methods_.Mutable(index);
}
inline void UnaryLimit::set_methods(int index, const std::string& value) {
  _impl_.methods_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
}
inline void UnaryLimit::set_methods(int index, std::string&& value) {
  _impl_.methods_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
}
inline void UnaryLimit::set_methods(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.methods_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
}
inline void UnaryLimit::set_methods(int index, const char* value, size_t size) {
  _impl_.methods_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
}
inline std::string* UnaryLimit::_internal_add_methods() {
  return _impl_.methods_.Add();
}
inline void UnaryLimit::add_methods(const std::string& value) {
  _impl_.methods_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
}
inline void UnaryLimit::add_methods(std::string&& value) {
  _impl_.methods_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
}
inline void UnaryLimit::add_methods(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.methods_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
}
inline void UnaryLimit::add_methods(const char* value, size_t size) {
  _impl_.methods_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UnaryLimit::methods() const {
  // @@protoc_insertion_point(field_list:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
  return _impl_.methods_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UnaryLimit::mutable_methods() {
  // @@protoc_insertion_point(field_mutable_list:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
  return &_impl_.methods_;
}

// -------------------------------------------------------------------

// StreamLimit

// int32 limit = 1;
inline void StreamLimit::clear_limit() {
  _impl_.limit_ = 0;
}
inline int32_t StreamLimit::_internal_limit() const {
  return _impl_.limit_;
}
inline int32_t StreamLimit::limit() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.StreamLimit.limit)
  return _internal_limit();
}
inline void StreamLimit::_internal_set_limit(int32_t value) {
  
  _impl_.limit_ = value;
}
inline void StreamLimit::set_limit(int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.StreamLimit.limit)
}

// repeated string streams = 2;
inline int StreamLimit::_internal_streams_size() const {
  return _impl_.streams_.size();
}
inline int StreamLimit::streams_size() const {
  return _internal_streams_size();
}
inline void StreamLimit::clear_streams() {
  _impl_.streams_.Clear();
}
inline std::string* StreamLimit::add_streams() {
  std::string* _s = _internal_add_streams();
  // @@protoc_insertion_point(field_add_mutable:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
  return _s;
}
inline const std::string& StreamLimit::_internal_streams(int index) const {
  return _impl_.streams_.Get(index);
}
inline const std::string& StreamLimit::streams(int index) const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
  return _internal_streams(index);
}
inline std::string* StreamLimit::mutable_streams(int index) {
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
  return _impl_.streams_.Mutable(index);
}
inline void StreamLimit::set_streams(int index, const std::string& value) {
  _impl_.streams_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
}
inline void StreamLimit::set_streams(int index, std::string&& value) {
  _impl_.streams_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
}
inline void StreamLimit::set_streams(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.streams_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
}
inline void StreamLimit::set_streams(int index, const char* value, size_t size) {
  _impl_.streams_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
}
inline std::string* StreamLimit::_internal_add_streams() {
  return _impl_.streams_.Add();
}
inline void StreamLimit::add_streams(const std::string& value) {
  _impl_.streams_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
}
inline void StreamLimit::add_streams(std::string&& value) {
  _impl_.streams_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
}
inline void StreamLimit::add_streams(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.streams_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
}
inline void StreamLimit::add_streams(const char* value, size_t size) {
  _impl_.streams_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamLimit::streams() const {
  // @@protoc_insertion_point(field_list:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
  return _impl_.streams_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamLimit::mutable_streams() {
  // @@protoc_insertion_point(field_mutable_list:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
  return &_impl_.streams_;
}

// int32 open = 3;
inline void StreamLimit::clear_open() {
  _impl_.open_ = 0;
}
inline int32_t StreamLimit::_internal_open() const {
  return _impl_.open_;
}
inline int32_t StreamLimit::open() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.StreamLimit.open)
  return _internal_open();
}
inline void StreamLimit::_internal_set_open(int32_t value) {
  
  _impl_.open_ = value;
}
inline void StreamLimit::set_open(int32_t value) {
  _internal_set_open(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.StreamLimit.open)
}

// -------------------------------------------------------------------

// GetInfoRequest

// -------------------------------------------------------------------

// GetInfoResponse

// bool prem_status = 1;
inline void GetInfoResponse::clear_prem_status() {
  _impl_.prem_status_ = false;
}
inline bool GetInfoResponse::_internal_prem_status() const {
  return _impl_.prem_status_;
}
inline bool GetInfoResponse::prem_status() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.prem_status)
  return _internal_prem_status();
}
inline void GetInfoResponse::_internal_set_prem_status(bool value) {
  
  _impl_.prem_status_ = value;
}
inline void GetInfoResponse::set_prem_status(bool value) {
  _internal_set_prem_status(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.prem_status)
}

// bool qual_status = 2;
inline void GetInfoResponse::clear_qual_status() {
  _impl_.qual_status_ = false;
}
inline bool GetInfoResponse::_internal_qual_status() const {
  return _impl_.qual_status_;
}
inline bool GetInfoResponse::qual_status() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qual_status)
  return _internal_qual_status();
}
inline void GetInfoResponse::_internal_set_qual_status(bool value) {
  
  _impl_.qual_status_ = value;
}
inline void GetInfoResponse::set_qual_status(bool value) {
  _internal_set_qual_status(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qual_status)
}

// repeated string qualified_for_work_with = 3;
inline int GetInfoResponse::_internal_qualified_for_work_with_size() const {
  return _impl_.qualified_for_work_with_.size();
}
inline int GetInfoResponse::qualified_for_work_with_size() const {
  return _internal_qualified_for_work_with_size();
}
inline void GetInfoResponse::clear_qualified_for_work_with() {
  _impl_.qualified_for_work_with_.Clear();
}
inline std::string* GetInfoResponse::add_qualified_for_work_with() {
  std::string* _s = _internal_add_qualified_for_work_with();
  // @@protoc_insertion_point(field_add_mutable:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
  return _s;
}
inline const std::string& GetInfoResponse::_internal_qualified_for_work_with(int index) const {
  return _impl_.qualified_for_work_with_.Get(index);
}
inline const std::string& GetInfoResponse::qualified_for_work_with(int index) const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
  return _internal_qualified_for_work_with(index);
}
inline std::string* GetInfoResponse::mutable_qualified_for_work_with(int index) {
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
  return _impl_.qualified_for_work_with_.Mutable(index);
}
inline void GetInfoResponse::set_qualified_for_work_with(int index, const std::string& value) {
  _impl_.qualified_for_work_with_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
}
inline void GetInfoResponse::set_qualified_for_work_with(int index, std::string&& value) {
  _impl_.qualified_for_work_with_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
}
inline void GetInfoResponse::set_qualified_for_work_with(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.qualified_for_work_with_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
}
inline void GetInfoResponse::set_qualified_for_work_with(int index, const char* value, size_t size) {
  _impl_.qualified_for_work_with_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
}
inline std::string* GetInfoResponse::_internal_add_qualified_for_work_with() {
  return _impl_.qualified_for_work_with_.Add();
}
inline void GetInfoResponse::add_qualified_for_work_with(const std::string& value) {
  _impl_.qualified_for_work_with_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
}
inline void GetInfoResponse::add_qualified_for_work_with(std::string&& value) {
  _impl_.qualified_for_work_with_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
}
inline void GetInfoResponse::add_qualified_for_work_with(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.qualified_for_work_with_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
}
inline void GetInfoResponse::add_qualified_for_work_with(const char* value, size_t size) {
  _impl_.qualified_for_work_with_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetInfoResponse::qualified_for_work_with() const {
  // @@protoc_insertion_point(field_list:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
  return _impl_.qualified_for_work_with_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetInfoResponse::mutable_qualified_for_work_with() {
  // @@protoc_insertion_point(field_mutable_list:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
  return &_impl_.qualified_for_work_with_;
}

// string tariff = 4;
inline void GetInfoResponse::clear_tariff() {
  _impl_.tariff_.ClearToEmpty();
}
inline const std::string& GetInfoResponse::tariff() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.tariff)
  return _internal_tariff();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetInfoResponse::set_tariff(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tariff_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.tariff)
}
inline std::string* GetInfoResponse::mutable_tariff() {
  std::string* _s = _internal_mutable_tariff();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.tariff)
  return _s;
}
inline const std::string& GetInfoResponse::_internal_tariff() const {
  return _impl_.tariff_.Get();
}
inline void GetInfoResponse::_internal_set_tariff(const std::string& value) {
  
  _impl_.tariff_.Set(value, GetArenaForAllocation());
}
inline std::string* GetInfoResponse::_internal_mutable_tariff() {
  
  return _impl_.tariff_.Mutable(GetArenaForAllocation());
}
inline std::string* GetInfoResponse::release_tariff() {
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.tariff)
  return _impl_.tariff_.Release();
}
inline void GetInfoResponse::set_allocated_tariff(std::string* tariff) {
  if (tariff != nullptr) {
    
  } else {
    
  }
  _impl_.tariff_.SetAllocated(tariff, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tariff_.IsDefault()) {
    _impl_.tariff_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.tariff)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace contract
}  // namespace api
}  // namespace invest
}  // namespace public_
}  // namespace tinkoff

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tinkoff::public_::invest::api::contract::v1::AccountType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tinkoff::public_::invest::api::contract::v1::AccountType>() {
  return ::tinkoff::public_::invest::api::contract::v1::AccountType_descriptor();
}
template <> struct is_proto_enum< ::tinkoff::public_::invest::api::contract::v1::AccountStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tinkoff::public_::invest::api::contract::v1::AccountStatus>() {
  return ::tinkoff::public_::invest::api::contract::v1::AccountStatus_descriptor();
}
template <> struct is_proto_enum< ::tinkoff::public_::invest::api::contract::v1::AccessLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tinkoff::public_::invest::api::contract::v1::AccessLevel>() {
  return ::tinkoff::public_::invest::api::contract::v1::AccessLevel_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_users_2eproto
