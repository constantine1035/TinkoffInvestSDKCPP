// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: users.proto
// Protobuf C++ Version: 4.25.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_users_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_users_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
#include "common.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_users_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_users_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_users_2eproto;
namespace tinkoff {
namespace public_ {
namespace invest {
namespace api {
namespace contract {
namespace v1 {
class Account;
struct AccountDefaultTypeInternal;
extern AccountDefaultTypeInternal _Account_default_instance_;
class GetAccountsRequest;
struct GetAccountsRequestDefaultTypeInternal;
extern GetAccountsRequestDefaultTypeInternal _GetAccountsRequest_default_instance_;
class GetAccountsResponse;
struct GetAccountsResponseDefaultTypeInternal;
extern GetAccountsResponseDefaultTypeInternal _GetAccountsResponse_default_instance_;
class GetInfoRequest;
struct GetInfoRequestDefaultTypeInternal;
extern GetInfoRequestDefaultTypeInternal _GetInfoRequest_default_instance_;
class GetInfoResponse;
struct GetInfoResponseDefaultTypeInternal;
extern GetInfoResponseDefaultTypeInternal _GetInfoResponse_default_instance_;
class GetMarginAttributesRequest;
struct GetMarginAttributesRequestDefaultTypeInternal;
extern GetMarginAttributesRequestDefaultTypeInternal _GetMarginAttributesRequest_default_instance_;
class GetMarginAttributesResponse;
struct GetMarginAttributesResponseDefaultTypeInternal;
extern GetMarginAttributesResponseDefaultTypeInternal _GetMarginAttributesResponse_default_instance_;
class GetUserTariffRequest;
struct GetUserTariffRequestDefaultTypeInternal;
extern GetUserTariffRequestDefaultTypeInternal _GetUserTariffRequest_default_instance_;
class GetUserTariffResponse;
struct GetUserTariffResponseDefaultTypeInternal;
extern GetUserTariffResponseDefaultTypeInternal _GetUserTariffResponse_default_instance_;
class StreamLimit;
struct StreamLimitDefaultTypeInternal;
extern StreamLimitDefaultTypeInternal _StreamLimit_default_instance_;
class UnaryLimit;
struct UnaryLimitDefaultTypeInternal;
extern UnaryLimitDefaultTypeInternal _UnaryLimit_default_instance_;
}  // namespace v1
}  // namespace contract
}  // namespace api
}  // namespace invest
}  // namespace public_
}  // namespace tinkoff
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace tinkoff {
namespace public_ {
namespace invest {
namespace api {
namespace contract {
namespace v1 {
enum AccountType : int {
  ACCOUNT_TYPE_UNSPECIFIED = 0,
  ACCOUNT_TYPE_TINKOFF = 1,
  ACCOUNT_TYPE_TINKOFF_IIS = 2,
  ACCOUNT_TYPE_INVEST_BOX = 3,
  AccountType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AccountType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AccountType_IsValid(int value);
extern const uint32_t AccountType_internal_data_[];
constexpr AccountType AccountType_MIN = static_cast<AccountType>(0);
constexpr AccountType AccountType_MAX = static_cast<AccountType>(3);
constexpr int AccountType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
AccountType_descriptor();
template <typename T>
const std::string& AccountType_Name(T value) {
  static_assert(std::is_same<T, AccountType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AccountType_Name().");
  return AccountType_Name(static_cast<AccountType>(value));
}
template <>
inline const std::string& AccountType_Name(AccountType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AccountType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool AccountType_Parse(absl::string_view name, AccountType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccountType>(
      AccountType_descriptor(), name, value);
}
enum AccountStatus : int {
  ACCOUNT_STATUS_UNSPECIFIED = 0,
  ACCOUNT_STATUS_NEW = 1,
  ACCOUNT_STATUS_OPEN = 2,
  ACCOUNT_STATUS_CLOSED = 3,
  AccountStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AccountStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AccountStatus_IsValid(int value);
extern const uint32_t AccountStatus_internal_data_[];
constexpr AccountStatus AccountStatus_MIN = static_cast<AccountStatus>(0);
constexpr AccountStatus AccountStatus_MAX = static_cast<AccountStatus>(3);
constexpr int AccountStatus_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
AccountStatus_descriptor();
template <typename T>
const std::string& AccountStatus_Name(T value) {
  static_assert(std::is_same<T, AccountStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AccountStatus_Name().");
  return AccountStatus_Name(static_cast<AccountStatus>(value));
}
template <>
inline const std::string& AccountStatus_Name(AccountStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AccountStatus_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool AccountStatus_Parse(absl::string_view name, AccountStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccountStatus>(
      AccountStatus_descriptor(), name, value);
}
enum AccessLevel : int {
  ACCOUNT_ACCESS_LEVEL_UNSPECIFIED = 0,
  ACCOUNT_ACCESS_LEVEL_FULL_ACCESS = 1,
  ACCOUNT_ACCESS_LEVEL_READ_ONLY = 2,
  ACCOUNT_ACCESS_LEVEL_NO_ACCESS = 3,
  AccessLevel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AccessLevel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AccessLevel_IsValid(int value);
extern const uint32_t AccessLevel_internal_data_[];
constexpr AccessLevel AccessLevel_MIN = static_cast<AccessLevel>(0);
constexpr AccessLevel AccessLevel_MAX = static_cast<AccessLevel>(3);
constexpr int AccessLevel_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
AccessLevel_descriptor();
template <typename T>
const std::string& AccessLevel_Name(T value) {
  static_assert(std::is_same<T, AccessLevel>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AccessLevel_Name().");
  return AccessLevel_Name(static_cast<AccessLevel>(value));
}
template <>
inline const std::string& AccessLevel_Name(AccessLevel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AccessLevel_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool AccessLevel_Parse(absl::string_view name, AccessLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccessLevel>(
      AccessLevel_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UnaryLimit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.UnaryLimit) */ {
 public:
  inline UnaryLimit() : UnaryLimit(nullptr) {}
  ~UnaryLimit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UnaryLimit(::google::protobuf::internal::ConstantInitialized);

  inline UnaryLimit(const UnaryLimit& from)
      : UnaryLimit(nullptr, from) {}
  UnaryLimit(UnaryLimit&& from) noexcept
    : UnaryLimit() {
    *this = ::std::move(from);
  }

  inline UnaryLimit& operator=(const UnaryLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnaryLimit& operator=(UnaryLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnaryLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnaryLimit* internal_default_instance() {
    return reinterpret_cast<const UnaryLimit*>(
               &_UnaryLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UnaryLimit& a, UnaryLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(UnaryLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnaryLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnaryLimit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnaryLimit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UnaryLimit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UnaryLimit& from) {
    UnaryLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UnaryLimit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.UnaryLimit";
  }
  protected:
  explicit UnaryLimit(::google::protobuf::Arena* arena);
  UnaryLimit(::google::protobuf::Arena* arena, const UnaryLimit& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMethodsFieldNumber = 2,
    kLimitPerMinuteFieldNumber = 1,
  };
  // repeated string methods = 2;
  int methods_size() const;
  private:
  int _internal_methods_size() const;

  public:
  void clear_methods() ;
  const std::string& methods(int index) const;
  std::string* mutable_methods(int index);
  void set_methods(int index, const std::string& value);
  void set_methods(int index, std::string&& value);
  void set_methods(int index, const char* value);
  void set_methods(int index, const char* value, std::size_t size);
  void set_methods(int index, absl::string_view value);
  std::string* add_methods();
  void add_methods(const std::string& value);
  void add_methods(std::string&& value);
  void add_methods(const char* value);
  void add_methods(const char* value, std::size_t size);
  void add_methods(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& methods() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_methods();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_methods() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_methods();

  public:
  // int32 limit_per_minute = 1;
  void clear_limit_per_minute() ;
  ::int32_t limit_per_minute() const;
  void set_limit_per_minute(::int32_t value);

  private:
  ::int32_t _internal_limit_per_minute() const;
  void _internal_set_limit_per_minute(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.UnaryLimit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      65, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> methods_;
    ::int32_t limit_per_minute_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_users_2eproto;
};// -------------------------------------------------------------------

class StreamLimit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.StreamLimit) */ {
 public:
  inline StreamLimit() : StreamLimit(nullptr) {}
  ~StreamLimit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamLimit(::google::protobuf::internal::ConstantInitialized);

  inline StreamLimit(const StreamLimit& from)
      : StreamLimit(nullptr, from) {}
  StreamLimit(StreamLimit&& from) noexcept
    : StreamLimit() {
    *this = ::std::move(from);
  }

  inline StreamLimit& operator=(const StreamLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamLimit& operator=(StreamLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamLimit* internal_default_instance() {
    return reinterpret_cast<const StreamLimit*>(
               &_StreamLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StreamLimit& a, StreamLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamLimit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamLimit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StreamLimit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StreamLimit& from) {
    StreamLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StreamLimit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.StreamLimit";
  }
  protected:
  explicit StreamLimit(::google::protobuf::Arena* arena);
  StreamLimit(::google::protobuf::Arena* arena, const StreamLimit& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamsFieldNumber = 2,
    kLimitFieldNumber = 1,
    kOpenFieldNumber = 3,
  };
  // repeated string streams = 2;
  int streams_size() const;
  private:
  int _internal_streams_size() const;

  public:
  void clear_streams() ;
  const std::string& streams(int index) const;
  std::string* mutable_streams(int index);
  void set_streams(int index, const std::string& value);
  void set_streams(int index, std::string&& value);
  void set_streams(int index, const char* value);
  void set_streams(int index, const char* value, std::size_t size);
  void set_streams(int index, absl::string_view value);
  std::string* add_streams();
  void add_streams(const std::string& value);
  void add_streams(std::string&& value);
  void add_streams(const char* value);
  void add_streams(const char* value, std::size_t size);
  void add_streams(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& streams() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_streams();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_streams() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_streams();

  public:
  // int32 limit = 1;
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // int32 open = 3;
  void clear_open() ;
  ::int32_t open() const;
  void set_open(::int32_t value);

  private:
  ::int32_t _internal_open() const;
  void _internal_set_open(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.StreamLimit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> streams_;
    ::int32_t limit_;
    ::int32_t open_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_users_2eproto;
};// -------------------------------------------------------------------

class GetUserTariffRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.GetUserTariffRequest) */ {
 public:
  inline GetUserTariffRequest() : GetUserTariffRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetUserTariffRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetUserTariffRequest(const GetUserTariffRequest& from)
      : GetUserTariffRequest(nullptr, from) {}
  GetUserTariffRequest(GetUserTariffRequest&& from) noexcept
    : GetUserTariffRequest() {
    *this = ::std::move(from);
  }

  inline GetUserTariffRequest& operator=(const GetUserTariffRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserTariffRequest& operator=(GetUserTariffRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserTariffRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserTariffRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserTariffRequest*>(
               &_GetUserTariffRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetUserTariffRequest& a, GetUserTariffRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserTariffRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserTariffRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserTariffRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserTariffRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetUserTariffRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetUserTariffRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.GetUserTariffRequest";
  }
  protected:
  explicit GetUserTariffRequest(::google::protobuf::Arena* arena);
  GetUserTariffRequest(::google::protobuf::Arena* arena, const GetUserTariffRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.GetUserTariffRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_users_2eproto;
};// -------------------------------------------------------------------

class GetMarginAttributesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesRequest) */ {
 public:
  inline GetMarginAttributesRequest() : GetMarginAttributesRequest(nullptr) {}
  ~GetMarginAttributesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetMarginAttributesRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetMarginAttributesRequest(const GetMarginAttributesRequest& from)
      : GetMarginAttributesRequest(nullptr, from) {}
  GetMarginAttributesRequest(GetMarginAttributesRequest&& from) noexcept
    : GetMarginAttributesRequest() {
    *this = ::std::move(from);
  }

  inline GetMarginAttributesRequest& operator=(const GetMarginAttributesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMarginAttributesRequest& operator=(GetMarginAttributesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMarginAttributesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMarginAttributesRequest* internal_default_instance() {
    return reinterpret_cast<const GetMarginAttributesRequest*>(
               &_GetMarginAttributesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetMarginAttributesRequest& a, GetMarginAttributesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMarginAttributesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMarginAttributesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMarginAttributesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMarginAttributesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetMarginAttributesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetMarginAttributesRequest& from) {
    GetMarginAttributesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetMarginAttributesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.GetMarginAttributesRequest";
  }
  protected:
  explicit GetMarginAttributesRequest(::google::protobuf::Arena* arena);
  GetMarginAttributesRequest(::google::protobuf::Arena* arena, const GetMarginAttributesRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
  };
  // string account_id = 1;
  void clear_account_id() ;
  const std::string& account_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_id(Arg_&& arg, Args_... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* value);

  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(
      const std::string& value);
  std::string* _internal_mutable_account_id();

  public:
  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      84, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr account_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_users_2eproto;
};// -------------------------------------------------------------------

class GetInfoResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.GetInfoResponse) */ {
 public:
  inline GetInfoResponse() : GetInfoResponse(nullptr) {}
  ~GetInfoResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetInfoResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetInfoResponse(const GetInfoResponse& from)
      : GetInfoResponse(nullptr, from) {}
  GetInfoResponse(GetInfoResponse&& from) noexcept
    : GetInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetInfoResponse& operator=(const GetInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetInfoResponse& operator=(GetInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetInfoResponse*>(
               &_GetInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetInfoResponse& a, GetInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetInfoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetInfoResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetInfoResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetInfoResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetInfoResponse& from) {
    GetInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetInfoResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.GetInfoResponse";
  }
  protected:
  explicit GetInfoResponse(::google::protobuf::Arena* arena);
  GetInfoResponse(::google::protobuf::Arena* arena, const GetInfoResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQualifiedForWorkWithFieldNumber = 3,
    kTariffFieldNumber = 4,
    kPremStatusFieldNumber = 1,
    kQualStatusFieldNumber = 2,
  };
  // repeated string qualified_for_work_with = 3;
  int qualified_for_work_with_size() const;
  private:
  int _internal_qualified_for_work_with_size() const;

  public:
  void clear_qualified_for_work_with() ;
  const std::string& qualified_for_work_with(int index) const;
  std::string* mutable_qualified_for_work_with(int index);
  void set_qualified_for_work_with(int index, const std::string& value);
  void set_qualified_for_work_with(int index, std::string&& value);
  void set_qualified_for_work_with(int index, const char* value);
  void set_qualified_for_work_with(int index, const char* value, std::size_t size);
  void set_qualified_for_work_with(int index, absl::string_view value);
  std::string* add_qualified_for_work_with();
  void add_qualified_for_work_with(const std::string& value);
  void add_qualified_for_work_with(std::string&& value);
  void add_qualified_for_work_with(const char* value);
  void add_qualified_for_work_with(const char* value, std::size_t size);
  void add_qualified_for_work_with(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& qualified_for_work_with() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_qualified_for_work_with();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_qualified_for_work_with() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_qualified_for_work_with();

  public:
  // string tariff = 4;
  void clear_tariff() ;
  const std::string& tariff() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tariff(Arg_&& arg, Args_... args);
  std::string* mutable_tariff();
  PROTOBUF_NODISCARD std::string* release_tariff();
  void set_allocated_tariff(std::string* value);

  private:
  const std::string& _internal_tariff() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tariff(
      const std::string& value);
  std::string* _internal_mutable_tariff();

  public:
  // bool prem_status = 1;
  void clear_prem_status() ;
  bool prem_status() const;
  void set_prem_status(bool value);

  private:
  bool _internal_prem_status() const;
  void _internal_set_prem_status(bool value);

  public:
  // bool qual_status = 2;
  void clear_qual_status() ;
  bool qual_status() const;
  void set_qual_status(bool value);

  private:
  bool _internal_qual_status() const;
  void _internal_set_qual_status(bool value);

  public:
  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.GetInfoResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      92, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> qualified_for_work_with_;
    ::google::protobuf::internal::ArenaStringPtr tariff_;
    bool prem_status_;
    bool qual_status_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_users_2eproto;
};// -------------------------------------------------------------------

class GetInfoRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.GetInfoRequest) */ {
 public:
  inline GetInfoRequest() : GetInfoRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetInfoRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetInfoRequest(const GetInfoRequest& from)
      : GetInfoRequest(nullptr, from) {}
  GetInfoRequest(GetInfoRequest&& from) noexcept
    : GetInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetInfoRequest& operator=(const GetInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetInfoRequest& operator=(GetInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetInfoRequest*>(
               &_GetInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetInfoRequest& a, GetInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetInfoRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetInfoRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetInfoRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetInfoRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.GetInfoRequest";
  }
  protected:
  explicit GetInfoRequest(::google::protobuf::Arena* arena);
  GetInfoRequest(::google::protobuf::Arena* arena, const GetInfoRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.GetInfoRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_users_2eproto;
};// -------------------------------------------------------------------

class GetAccountsRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.GetAccountsRequest) */ {
 public:
  inline GetAccountsRequest() : GetAccountsRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetAccountsRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetAccountsRequest(const GetAccountsRequest& from)
      : GetAccountsRequest(nullptr, from) {}
  GetAccountsRequest(GetAccountsRequest&& from) noexcept
    : GetAccountsRequest() {
    *this = ::std::move(from);
  }

  inline GetAccountsRequest& operator=(const GetAccountsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountsRequest& operator=(GetAccountsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccountsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAccountsRequest* internal_default_instance() {
    return reinterpret_cast<const GetAccountsRequest*>(
               &_GetAccountsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetAccountsRequest& a, GetAccountsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccountsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccountsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAccountsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAccountsRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetAccountsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetAccountsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.GetAccountsRequest";
  }
  protected:
  explicit GetAccountsRequest(::google::protobuf::Arena* arena);
  GetAccountsRequest(::google::protobuf::Arena* arena, const GetAccountsRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.GetAccountsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_users_2eproto;
};// -------------------------------------------------------------------

class GetUserTariffResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse) */ {
 public:
  inline GetUserTariffResponse() : GetUserTariffResponse(nullptr) {}
  ~GetUserTariffResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetUserTariffResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetUserTariffResponse(const GetUserTariffResponse& from)
      : GetUserTariffResponse(nullptr, from) {}
  GetUserTariffResponse(GetUserTariffResponse&& from) noexcept
    : GetUserTariffResponse() {
    *this = ::std::move(from);
  }

  inline GetUserTariffResponse& operator=(const GetUserTariffResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserTariffResponse& operator=(GetUserTariffResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserTariffResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserTariffResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserTariffResponse*>(
               &_GetUserTariffResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetUserTariffResponse& a, GetUserTariffResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserTariffResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserTariffResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserTariffResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserTariffResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetUserTariffResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetUserTariffResponse& from) {
    GetUserTariffResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetUserTariffResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse";
  }
  protected:
  explicit GetUserTariffResponse(::google::protobuf::Arena* arena);
  GetUserTariffResponse(::google::protobuf::Arena* arena, const GetUserTariffResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnaryLimitsFieldNumber = 1,
    kStreamLimitsFieldNumber = 2,
  };
  // repeated .tinkoff.public_.invest.api.contract.v1.UnaryLimit unary_limits = 1;
  int unary_limits_size() const;
  private:
  int _internal_unary_limits_size() const;

  public:
  void clear_unary_limits() ;
  ::tinkoff::public_::invest::api::contract::v1::UnaryLimit* mutable_unary_limits(int index);
  ::google::protobuf::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::UnaryLimit >*
      mutable_unary_limits();
  private:
  const ::google::protobuf::RepeatedPtrField<::tinkoff::public_::invest::api::contract::v1::UnaryLimit>& _internal_unary_limits() const;
  ::google::protobuf::RepeatedPtrField<::tinkoff::public_::invest::api::contract::v1::UnaryLimit>* _internal_mutable_unary_limits();
  public:
  const ::tinkoff::public_::invest::api::contract::v1::UnaryLimit& unary_limits(int index) const;
  ::tinkoff::public_::invest::api::contract::v1::UnaryLimit* add_unary_limits();
  const ::google::protobuf::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::UnaryLimit >&
      unary_limits() const;
  // repeated .tinkoff.public_.invest.api.contract.v1.StreamLimit stream_limits = 2;
  int stream_limits_size() const;
  private:
  int _internal_stream_limits_size() const;

  public:
  void clear_stream_limits() ;
  ::tinkoff::public_::invest::api::contract::v1::StreamLimit* mutable_stream_limits(int index);
  ::google::protobuf::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::StreamLimit >*
      mutable_stream_limits();
  private:
  const ::google::protobuf::RepeatedPtrField<::tinkoff::public_::invest::api::contract::v1::StreamLimit>& _internal_stream_limits() const;
  ::google::protobuf::RepeatedPtrField<::tinkoff::public_::invest::api::contract::v1::StreamLimit>* _internal_mutable_stream_limits();
  public:
  const ::tinkoff::public_::invest::api::contract::v1::StreamLimit& stream_limits(int index) const;
  ::tinkoff::public_::invest::api::contract::v1::StreamLimit* add_stream_limits();
  const ::google::protobuf::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::StreamLimit >&
      stream_limits() const;
  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::UnaryLimit > unary_limits_;
    ::google::protobuf::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::StreamLimit > stream_limits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_users_2eproto;
};// -------------------------------------------------------------------

class GetMarginAttributesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse) */ {
 public:
  inline GetMarginAttributesResponse() : GetMarginAttributesResponse(nullptr) {}
  ~GetMarginAttributesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetMarginAttributesResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetMarginAttributesResponse(const GetMarginAttributesResponse& from)
      : GetMarginAttributesResponse(nullptr, from) {}
  GetMarginAttributesResponse(GetMarginAttributesResponse&& from) noexcept
    : GetMarginAttributesResponse() {
    *this = ::std::move(from);
  }

  inline GetMarginAttributesResponse& operator=(const GetMarginAttributesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMarginAttributesResponse& operator=(GetMarginAttributesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMarginAttributesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMarginAttributesResponse* internal_default_instance() {
    return reinterpret_cast<const GetMarginAttributesResponse*>(
               &_GetMarginAttributesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetMarginAttributesResponse& a, GetMarginAttributesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMarginAttributesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMarginAttributesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMarginAttributesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMarginAttributesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetMarginAttributesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetMarginAttributesResponse& from) {
    GetMarginAttributesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetMarginAttributesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse";
  }
  protected:
  explicit GetMarginAttributesResponse(::google::protobuf::Arena* arena);
  GetMarginAttributesResponse(::google::protobuf::Arena* arena, const GetMarginAttributesResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiquidPortfolioFieldNumber = 1,
    kStartingMarginFieldNumber = 2,
    kMinimalMarginFieldNumber = 3,
    kFundsSufficiencyLevelFieldNumber = 4,
    kAmountOfMissingFundsFieldNumber = 5,
    kCorrectedMarginFieldNumber = 6,
  };
  // .tinkoff.public_.invest.api.contract.v1.MoneyValue liquid_portfolio = 1;
  bool has_liquid_portfolio() const;
  void clear_liquid_portfolio() ;
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& liquid_portfolio() const;
  PROTOBUF_NODISCARD ::tinkoff::public_::invest::api::contract::v1::MoneyValue* release_liquid_portfolio();
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* mutable_liquid_portfolio();
  void set_allocated_liquid_portfolio(::tinkoff::public_::invest::api::contract::v1::MoneyValue* value);
  void unsafe_arena_set_allocated_liquid_portfolio(::tinkoff::public_::invest::api::contract::v1::MoneyValue* value);
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* unsafe_arena_release_liquid_portfolio();

  private:
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& _internal_liquid_portfolio() const;
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* _internal_mutable_liquid_portfolio();

  public:
  // .tinkoff.public_.invest.api.contract.v1.MoneyValue starting_margin = 2;
  bool has_starting_margin() const;
  void clear_starting_margin() ;
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& starting_margin() const;
  PROTOBUF_NODISCARD ::tinkoff::public_::invest::api::contract::v1::MoneyValue* release_starting_margin();
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* mutable_starting_margin();
  void set_allocated_starting_margin(::tinkoff::public_::invest::api::contract::v1::MoneyValue* value);
  void unsafe_arena_set_allocated_starting_margin(::tinkoff::public_::invest::api::contract::v1::MoneyValue* value);
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* unsafe_arena_release_starting_margin();

  private:
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& _internal_starting_margin() const;
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* _internal_mutable_starting_margin();

  public:
  // .tinkoff.public_.invest.api.contract.v1.MoneyValue minimal_margin = 3;
  bool has_minimal_margin() const;
  void clear_minimal_margin() ;
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& minimal_margin() const;
  PROTOBUF_NODISCARD ::tinkoff::public_::invest::api::contract::v1::MoneyValue* release_minimal_margin();
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* mutable_minimal_margin();
  void set_allocated_minimal_margin(::tinkoff::public_::invest::api::contract::v1::MoneyValue* value);
  void unsafe_arena_set_allocated_minimal_margin(::tinkoff::public_::invest::api::contract::v1::MoneyValue* value);
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* unsafe_arena_release_minimal_margin();

  private:
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& _internal_minimal_margin() const;
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* _internal_mutable_minimal_margin();

  public:
  // .tinkoff.public_.invest.api.contract.v1.Quotation funds_sufficiency_level = 4;
  bool has_funds_sufficiency_level() const;
  void clear_funds_sufficiency_level() ;
  const ::tinkoff::public_::invest::api::contract::v1::Quotation& funds_sufficiency_level() const;
  PROTOBUF_NODISCARD ::tinkoff::public_::invest::api::contract::v1::Quotation* release_funds_sufficiency_level();
  ::tinkoff::public_::invest::api::contract::v1::Quotation* mutable_funds_sufficiency_level();
  void set_allocated_funds_sufficiency_level(::tinkoff::public_::invest::api::contract::v1::Quotation* value);
  void unsafe_arena_set_allocated_funds_sufficiency_level(::tinkoff::public_::invest::api::contract::v1::Quotation* value);
  ::tinkoff::public_::invest::api::contract::v1::Quotation* unsafe_arena_release_funds_sufficiency_level();

  private:
  const ::tinkoff::public_::invest::api::contract::v1::Quotation& _internal_funds_sufficiency_level() const;
  ::tinkoff::public_::invest::api::contract::v1::Quotation* _internal_mutable_funds_sufficiency_level();

  public:
  // .tinkoff.public_.invest.api.contract.v1.MoneyValue amount_of_missing_funds = 5;
  bool has_amount_of_missing_funds() const;
  void clear_amount_of_missing_funds() ;
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& amount_of_missing_funds() const;
  PROTOBUF_NODISCARD ::tinkoff::public_::invest::api::contract::v1::MoneyValue* release_amount_of_missing_funds();
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* mutable_amount_of_missing_funds();
  void set_allocated_amount_of_missing_funds(::tinkoff::public_::invest::api::contract::v1::MoneyValue* value);
  void unsafe_arena_set_allocated_amount_of_missing_funds(::tinkoff::public_::invest::api::contract::v1::MoneyValue* value);
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* unsafe_arena_release_amount_of_missing_funds();

  private:
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& _internal_amount_of_missing_funds() const;
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* _internal_mutable_amount_of_missing_funds();

  public:
  // .tinkoff.public_.invest.api.contract.v1.MoneyValue corrected_margin = 6;
  bool has_corrected_margin() const;
  void clear_corrected_margin() ;
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& corrected_margin() const;
  PROTOBUF_NODISCARD ::tinkoff::public_::invest::api::contract::v1::MoneyValue* release_corrected_margin();
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* mutable_corrected_margin();
  void set_allocated_corrected_margin(::tinkoff::public_::invest::api::contract::v1::MoneyValue* value);
  void unsafe_arena_set_allocated_corrected_margin(::tinkoff::public_::invest::api::contract::v1::MoneyValue* value);
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* unsafe_arena_release_corrected_margin();

  private:
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& _internal_corrected_margin() const;
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* _internal_mutable_corrected_margin();

  public:
  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 6,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::tinkoff::public_::invest::api::contract::v1::MoneyValue* liquid_portfolio_;
    ::tinkoff::public_::invest::api::contract::v1::MoneyValue* starting_margin_;
    ::tinkoff::public_::invest::api::contract::v1::MoneyValue* minimal_margin_;
    ::tinkoff::public_::invest::api::contract::v1::Quotation* funds_sufficiency_level_;
    ::tinkoff::public_::invest::api::contract::v1::MoneyValue* amount_of_missing_funds_;
    ::tinkoff::public_::invest::api::contract::v1::MoneyValue* corrected_margin_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_users_2eproto;
};// -------------------------------------------------------------------

class Account final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.Account) */ {
 public:
  inline Account() : Account(nullptr) {}
  ~Account() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Account(::google::protobuf::internal::ConstantInitialized);

  inline Account(const Account& from)
      : Account(nullptr, from) {}
  Account(Account&& from) noexcept
    : Account() {
    *this = ::std::move(from);
  }

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }
  inline Account& operator=(Account&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Account& default_instance() {
    return *internal_default_instance();
  }
  static inline const Account* internal_default_instance() {
    return reinterpret_cast<const Account*>(
               &_Account_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Account& a, Account& b) {
    a.Swap(&b);
  }
  inline void Swap(Account* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Account* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Account* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Account>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Account& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Account& from) {
    Account::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Account* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.Account";
  }
  protected:
  explicit Account(::google::protobuf::Arena* arena);
  Account(::google::protobuf::Arena* arena, const Account& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 3,
    kOpenedDateFieldNumber = 5,
    kClosedDateFieldNumber = 6,
    kTypeFieldNumber = 2,
    kStatusFieldNumber = 4,
    kAccessLevelFieldNumber = 7,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string name = 3;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .google.protobuf.Timestamp opened_date = 5;
  bool has_opened_date() const;
  void clear_opened_date() ;
  const ::google::protobuf::Timestamp& opened_date() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_opened_date();
  ::google::protobuf::Timestamp* mutable_opened_date();
  void set_allocated_opened_date(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_opened_date(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_opened_date();

  private:
  const ::google::protobuf::Timestamp& _internal_opened_date() const;
  ::google::protobuf::Timestamp* _internal_mutable_opened_date();

  public:
  // .google.protobuf.Timestamp closed_date = 6;
  bool has_closed_date() const;
  void clear_closed_date() ;
  const ::google::protobuf::Timestamp& closed_date() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_closed_date();
  ::google::protobuf::Timestamp* mutable_closed_date();
  void set_allocated_closed_date(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_closed_date(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_closed_date();

  private:
  const ::google::protobuf::Timestamp& _internal_closed_date() const;
  ::google::protobuf::Timestamp* _internal_mutable_closed_date();

  public:
  // .tinkoff.public_.invest.api.contract.v1.AccountType type = 2;
  void clear_type() ;
  ::tinkoff::public_::invest::api::contract::v1::AccountType type() const;
  void set_type(::tinkoff::public_::invest::api::contract::v1::AccountType value);

  private:
  ::tinkoff::public_::invest::api::contract::v1::AccountType _internal_type() const;
  void _internal_set_type(::tinkoff::public_::invest::api::contract::v1::AccountType value);

  public:
  // .tinkoff.public_.invest.api.contract.v1.AccountStatus status = 4;
  void clear_status() ;
  ::tinkoff::public_::invest::api::contract::v1::AccountStatus status() const;
  void set_status(::tinkoff::public_::invest::api::contract::v1::AccountStatus value);

  private:
  ::tinkoff::public_::invest::api::contract::v1::AccountStatus _internal_status() const;
  void _internal_set_status(::tinkoff::public_::invest::api::contract::v1::AccountStatus value);

  public:
  // .tinkoff.public_.invest.api.contract.v1.AccessLevel access_level = 7;
  void clear_access_level() ;
  ::tinkoff::public_::invest::api::contract::v1::AccessLevel access_level() const;
  void set_access_level(::tinkoff::public_::invest::api::contract::v1::AccessLevel value);

  private:
  ::tinkoff::public_::invest::api::contract::v1::AccessLevel _internal_access_level() const;
  void _internal_set_access_level(::tinkoff::public_::invest::api::contract::v1::AccessLevel value);

  public:
  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.Account)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::Timestamp* opened_date_;
    ::google::protobuf::Timestamp* closed_date_;
    int type_;
    int status_;
    int access_level_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_users_2eproto;
};// -------------------------------------------------------------------

class GetAccountsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tinkoff.public_.invest.api.contract.v1.GetAccountsResponse) */ {
 public:
  inline GetAccountsResponse() : GetAccountsResponse(nullptr) {}
  ~GetAccountsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetAccountsResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetAccountsResponse(const GetAccountsResponse& from)
      : GetAccountsResponse(nullptr, from) {}
  GetAccountsResponse(GetAccountsResponse&& from) noexcept
    : GetAccountsResponse() {
    *this = ::std::move(from);
  }

  inline GetAccountsResponse& operator=(const GetAccountsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountsResponse& operator=(GetAccountsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccountsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAccountsResponse* internal_default_instance() {
    return reinterpret_cast<const GetAccountsResponse*>(
               &_GetAccountsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetAccountsResponse& a, GetAccountsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccountsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccountsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAccountsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAccountsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetAccountsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetAccountsResponse& from) {
    GetAccountsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetAccountsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tinkoff.public_.invest.api.contract.v1.GetAccountsResponse";
  }
  protected:
  explicit GetAccountsResponse(::google::protobuf::Arena* arena);
  GetAccountsResponse(::google::protobuf::Arena* arena, const GetAccountsResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountsFieldNumber = 1,
  };
  // repeated .tinkoff.public_.invest.api.contract.v1.Account accounts = 1;
  int accounts_size() const;
  private:
  int _internal_accounts_size() const;

  public:
  void clear_accounts() ;
  ::tinkoff::public_::invest::api::contract::v1::Account* mutable_accounts(int index);
  ::google::protobuf::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::Account >*
      mutable_accounts();
  private:
  const ::google::protobuf::RepeatedPtrField<::tinkoff::public_::invest::api::contract::v1::Account>& _internal_accounts() const;
  ::google::protobuf::RepeatedPtrField<::tinkoff::public_::invest::api::contract::v1::Account>* _internal_mutable_accounts();
  public:
  const ::tinkoff::public_::invest::api::contract::v1::Account& accounts(int index) const;
  ::tinkoff::public_::invest::api::contract::v1::Account* add_accounts();
  const ::google::protobuf::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::Account >&
      accounts() const;
  // @@protoc_insertion_point(class_scope:tinkoff.public_.invest.api.contract.v1.GetAccountsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::tinkoff::public_::invest::api::contract::v1::Account > accounts_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_users_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GetAccountsRequest

// -------------------------------------------------------------------

// GetAccountsResponse

// repeated .tinkoff.public_.invest.api.contract.v1.Account accounts = 1;
inline int GetAccountsResponse::_internal_accounts_size() const {
  return _internal_accounts().size();
}
inline int GetAccountsResponse::accounts_size() const {
  return _internal_accounts_size();
}
inline void GetAccountsResponse::clear_accounts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accounts_.Clear();
}
inline ::tinkoff::public_::invest::api::contract::v1::Account* GetAccountsResponse::mutable_accounts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetAccountsResponse.accounts)
  return _internal_mutable_accounts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tinkoff::public_::invest::api::contract::v1::Account>* GetAccountsResponse::mutable_accounts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tinkoff.public_.invest.api.contract.v1.GetAccountsResponse.accounts)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_accounts();
}
inline const ::tinkoff::public_::invest::api::contract::v1::Account& GetAccountsResponse::accounts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetAccountsResponse.accounts)
  return _internal_accounts().Get(index);
}
inline ::tinkoff::public_::invest::api::contract::v1::Account* GetAccountsResponse::add_accounts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::tinkoff::public_::invest::api::contract::v1::Account* _add = _internal_mutable_accounts()->Add();
  // @@protoc_insertion_point(field_add:tinkoff.public_.invest.api.contract.v1.GetAccountsResponse.accounts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tinkoff::public_::invest::api::contract::v1::Account>& GetAccountsResponse::accounts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tinkoff.public_.invest.api.contract.v1.GetAccountsResponse.accounts)
  return _internal_accounts();
}
inline const ::google::protobuf::RepeatedPtrField<::tinkoff::public_::invest::api::contract::v1::Account>&
GetAccountsResponse::_internal_accounts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.accounts_;
}
inline ::google::protobuf::RepeatedPtrField<::tinkoff::public_::invest::api::contract::v1::Account>*
GetAccountsResponse::_internal_mutable_accounts() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.accounts_;
}

// -------------------------------------------------------------------

// Account

// string id = 1;
inline void Account::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Account::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.Account.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Account::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.Account.id)
}
inline std::string* Account::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.Account.id)
  return _s;
}
inline const std::string& Account::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Account::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* Account::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* Account::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.Account.id)
  return _impl_.id_.Release();
}
inline void Account::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.Account.id)
}

// .tinkoff.public_.invest.api.contract.v1.AccountType type = 2;
inline void Account::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::tinkoff::public_::invest::api::contract::v1::AccountType Account::type() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.Account.type)
  return _internal_type();
}
inline void Account::set_type(::tinkoff::public_::invest::api::contract::v1::AccountType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.Account.type)
}
inline ::tinkoff::public_::invest::api::contract::v1::AccountType Account::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::tinkoff::public_::invest::api::contract::v1::AccountType>(_impl_.type_);
}
inline void Account::_internal_set_type(::tinkoff::public_::invest::api::contract::v1::AccountType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// string name = 3;
inline void Account::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Account::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.Account.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Account::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.Account.name)
}
inline std::string* Account::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.Account.name)
  return _s;
}
inline const std::string& Account::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Account::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Account::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Account::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.Account.name)
  return _impl_.name_.Release();
}
inline void Account::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.Account.name)
}

// .tinkoff.public_.invest.api.contract.v1.AccountStatus status = 4;
inline void Account::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = 0;
}
inline ::tinkoff::public_::invest::api::contract::v1::AccountStatus Account::status() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.Account.status)
  return _internal_status();
}
inline void Account::set_status(::tinkoff::public_::invest::api::contract::v1::AccountStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.Account.status)
}
inline ::tinkoff::public_::invest::api::contract::v1::AccountStatus Account::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::tinkoff::public_::invest::api::contract::v1::AccountStatus>(_impl_.status_);
}
inline void Account::_internal_set_status(::tinkoff::public_::invest::api::contract::v1::AccountStatus value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_ = value;
}

// .google.protobuf.Timestamp opened_date = 5;
inline bool Account::has_opened_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.opened_date_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Account::_internal_opened_date() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.opened_date_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Account::opened_date() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.Account.opened_date)
  return _internal_opened_date();
}
inline void Account::unsafe_arena_set_allocated_opened_date(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.opened_date_);
  }
  _impl_.opened_date_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tinkoff.public_.invest.api.contract.v1.Account.opened_date)
}
inline ::google::protobuf::Timestamp* Account::release_opened_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.opened_date_;
  _impl_.opened_date_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Account::unsafe_arena_release_opened_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.Account.opened_date)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.opened_date_;
  _impl_.opened_date_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Account::_internal_mutable_opened_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.opened_date_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.opened_date_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.opened_date_;
}
inline ::google::protobuf::Timestamp* Account::mutable_opened_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_opened_date();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.Account.opened_date)
  return _msg;
}
inline void Account::set_allocated_opened_date(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.opened_date_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.opened_date_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.Account.opened_date)
}

// .google.protobuf.Timestamp closed_date = 6;
inline bool Account::has_closed_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.closed_date_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Account::_internal_closed_date() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.closed_date_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Account::closed_date() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.Account.closed_date)
  return _internal_closed_date();
}
inline void Account::unsafe_arena_set_allocated_closed_date(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.closed_date_);
  }
  _impl_.closed_date_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tinkoff.public_.invest.api.contract.v1.Account.closed_date)
}
inline ::google::protobuf::Timestamp* Account::release_closed_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.closed_date_;
  _impl_.closed_date_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Account::unsafe_arena_release_closed_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.Account.closed_date)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.closed_date_;
  _impl_.closed_date_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Account::_internal_mutable_closed_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.closed_date_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.closed_date_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.closed_date_;
}
inline ::google::protobuf::Timestamp* Account::mutable_closed_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_closed_date();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.Account.closed_date)
  return _msg;
}
inline void Account::set_allocated_closed_date(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.closed_date_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.closed_date_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.Account.closed_date)
}

// .tinkoff.public_.invest.api.contract.v1.AccessLevel access_level = 7;
inline void Account::clear_access_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.access_level_ = 0;
}
inline ::tinkoff::public_::invest::api::contract::v1::AccessLevel Account::access_level() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.Account.access_level)
  return _internal_access_level();
}
inline void Account::set_access_level(::tinkoff::public_::invest::api::contract::v1::AccessLevel value) {
  _internal_set_access_level(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.Account.access_level)
}
inline ::tinkoff::public_::invest::api::contract::v1::AccessLevel Account::_internal_access_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::tinkoff::public_::invest::api::contract::v1::AccessLevel>(_impl_.access_level_);
}
inline void Account::_internal_set_access_level(::tinkoff::public_::invest::api::contract::v1::AccessLevel value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.access_level_ = value;
}

// -------------------------------------------------------------------

// GetMarginAttributesRequest

// string account_id = 1;
inline void GetMarginAttributesRequest::clear_account_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& GetMarginAttributesRequest::account_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesRequest.account_id)
  return _internal_account_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetMarginAttributesRequest::set_account_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.account_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesRequest.account_id)
}
inline std::string* GetMarginAttributesRequest::mutable_account_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesRequest.account_id)
  return _s;
}
inline const std::string& GetMarginAttributesRequest::_internal_account_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.account_id_.Get();
}
inline void GetMarginAttributesRequest::_internal_set_account_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.account_id_.Set(value, GetArena());
}
inline std::string* GetMarginAttributesRequest::_internal_mutable_account_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.account_id_.Mutable( GetArena());
}
inline std::string* GetMarginAttributesRequest::release_account_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesRequest.account_id)
  return _impl_.account_id_.Release();
}
inline void GetMarginAttributesRequest::set_allocated_account_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.account_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_id_.IsDefault()) {
          _impl_.account_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesRequest.account_id)
}

// -------------------------------------------------------------------

// GetMarginAttributesResponse

// .tinkoff.public_.invest.api.contract.v1.MoneyValue liquid_portfolio = 1;
inline bool GetMarginAttributesResponse::has_liquid_portfolio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.liquid_portfolio_ != nullptr);
  return value;
}
inline const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& GetMarginAttributesResponse::_internal_liquid_portfolio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue* p = _impl_.liquid_portfolio_;
  return p != nullptr ? *p : reinterpret_cast<const ::tinkoff::public_::invest::api::contract::v1::MoneyValue&>(::tinkoff::public_::invest::api::contract::v1::_MoneyValue_default_instance_);
}
inline const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& GetMarginAttributesResponse::liquid_portfolio() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.liquid_portfolio)
  return _internal_liquid_portfolio();
}
inline void GetMarginAttributesResponse::unsafe_arena_set_allocated_liquid_portfolio(::tinkoff::public_::invest::api::contract::v1::MoneyValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.liquid_portfolio_);
  }
  _impl_.liquid_portfolio_ = reinterpret_cast<::tinkoff::public_::invest::api::contract::v1::MoneyValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.liquid_portfolio)
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::release_liquid_portfolio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* released = _impl_.liquid_portfolio_;
  _impl_.liquid_portfolio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::unsafe_arena_release_liquid_portfolio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.liquid_portfolio)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* temp = _impl_.liquid_portfolio_;
  _impl_.liquid_portfolio_ = nullptr;
  return temp;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::_internal_mutable_liquid_portfolio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.liquid_portfolio_ == nullptr) {
    auto* p = CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::MoneyValue>(GetArena());
    _impl_.liquid_portfolio_ = reinterpret_cast<::tinkoff::public_::invest::api::contract::v1::MoneyValue*>(p);
  }
  return _impl_.liquid_portfolio_;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::mutable_liquid_portfolio() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* _msg = _internal_mutable_liquid_portfolio();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.liquid_portfolio)
  return _msg;
}
inline void GetMarginAttributesResponse::set_allocated_liquid_portfolio(::tinkoff::public_::invest::api::contract::v1::MoneyValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.liquid_portfolio_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.liquid_portfolio_ = reinterpret_cast<::tinkoff::public_::invest::api::contract::v1::MoneyValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.liquid_portfolio)
}

// .tinkoff.public_.invest.api.contract.v1.MoneyValue starting_margin = 2;
inline bool GetMarginAttributesResponse::has_starting_margin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.starting_margin_ != nullptr);
  return value;
}
inline const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& GetMarginAttributesResponse::_internal_starting_margin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue* p = _impl_.starting_margin_;
  return p != nullptr ? *p : reinterpret_cast<const ::tinkoff::public_::invest::api::contract::v1::MoneyValue&>(::tinkoff::public_::invest::api::contract::v1::_MoneyValue_default_instance_);
}
inline const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& GetMarginAttributesResponse::starting_margin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.starting_margin)
  return _internal_starting_margin();
}
inline void GetMarginAttributesResponse::unsafe_arena_set_allocated_starting_margin(::tinkoff::public_::invest::api::contract::v1::MoneyValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.starting_margin_);
  }
  _impl_.starting_margin_ = reinterpret_cast<::tinkoff::public_::invest::api::contract::v1::MoneyValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.starting_margin)
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::release_starting_margin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* released = _impl_.starting_margin_;
  _impl_.starting_margin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::unsafe_arena_release_starting_margin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.starting_margin)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* temp = _impl_.starting_margin_;
  _impl_.starting_margin_ = nullptr;
  return temp;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::_internal_mutable_starting_margin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.starting_margin_ == nullptr) {
    auto* p = CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::MoneyValue>(GetArena());
    _impl_.starting_margin_ = reinterpret_cast<::tinkoff::public_::invest::api::contract::v1::MoneyValue*>(p);
  }
  return _impl_.starting_margin_;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::mutable_starting_margin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* _msg = _internal_mutable_starting_margin();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.starting_margin)
  return _msg;
}
inline void GetMarginAttributesResponse::set_allocated_starting_margin(::tinkoff::public_::invest::api::contract::v1::MoneyValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.starting_margin_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.starting_margin_ = reinterpret_cast<::tinkoff::public_::invest::api::contract::v1::MoneyValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.starting_margin)
}

// .tinkoff.public_.invest.api.contract.v1.MoneyValue minimal_margin = 3;
inline bool GetMarginAttributesResponse::has_minimal_margin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.minimal_margin_ != nullptr);
  return value;
}
inline const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& GetMarginAttributesResponse::_internal_minimal_margin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue* p = _impl_.minimal_margin_;
  return p != nullptr ? *p : reinterpret_cast<const ::tinkoff::public_::invest::api::contract::v1::MoneyValue&>(::tinkoff::public_::invest::api::contract::v1::_MoneyValue_default_instance_);
}
inline const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& GetMarginAttributesResponse::minimal_margin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.minimal_margin)
  return _internal_minimal_margin();
}
inline void GetMarginAttributesResponse::unsafe_arena_set_allocated_minimal_margin(::tinkoff::public_::invest::api::contract::v1::MoneyValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.minimal_margin_);
  }
  _impl_.minimal_margin_ = reinterpret_cast<::tinkoff::public_::invest::api::contract::v1::MoneyValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.minimal_margin)
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::release_minimal_margin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* released = _impl_.minimal_margin_;
  _impl_.minimal_margin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::unsafe_arena_release_minimal_margin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.minimal_margin)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* temp = _impl_.minimal_margin_;
  _impl_.minimal_margin_ = nullptr;
  return temp;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::_internal_mutable_minimal_margin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.minimal_margin_ == nullptr) {
    auto* p = CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::MoneyValue>(GetArena());
    _impl_.minimal_margin_ = reinterpret_cast<::tinkoff::public_::invest::api::contract::v1::MoneyValue*>(p);
  }
  return _impl_.minimal_margin_;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::mutable_minimal_margin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* _msg = _internal_mutable_minimal_margin();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.minimal_margin)
  return _msg;
}
inline void GetMarginAttributesResponse::set_allocated_minimal_margin(::tinkoff::public_::invest::api::contract::v1::MoneyValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.minimal_margin_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.minimal_margin_ = reinterpret_cast<::tinkoff::public_::invest::api::contract::v1::MoneyValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.minimal_margin)
}

// .tinkoff.public_.invest.api.contract.v1.Quotation funds_sufficiency_level = 4;
inline bool GetMarginAttributesResponse::has_funds_sufficiency_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.funds_sufficiency_level_ != nullptr);
  return value;
}
inline const ::tinkoff::public_::invest::api::contract::v1::Quotation& GetMarginAttributesResponse::_internal_funds_sufficiency_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::tinkoff::public_::invest::api::contract::v1::Quotation* p = _impl_.funds_sufficiency_level_;
  return p != nullptr ? *p : reinterpret_cast<const ::tinkoff::public_::invest::api::contract::v1::Quotation&>(::tinkoff::public_::invest::api::contract::v1::_Quotation_default_instance_);
}
inline const ::tinkoff::public_::invest::api::contract::v1::Quotation& GetMarginAttributesResponse::funds_sufficiency_level() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.funds_sufficiency_level)
  return _internal_funds_sufficiency_level();
}
inline void GetMarginAttributesResponse::unsafe_arena_set_allocated_funds_sufficiency_level(::tinkoff::public_::invest::api::contract::v1::Quotation* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.funds_sufficiency_level_);
  }
  _impl_.funds_sufficiency_level_ = reinterpret_cast<::tinkoff::public_::invest::api::contract::v1::Quotation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.funds_sufficiency_level)
}
inline ::tinkoff::public_::invest::api::contract::v1::Quotation* GetMarginAttributesResponse::release_funds_sufficiency_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::tinkoff::public_::invest::api::contract::v1::Quotation* released = _impl_.funds_sufficiency_level_;
  _impl_.funds_sufficiency_level_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tinkoff::public_::invest::api::contract::v1::Quotation* GetMarginAttributesResponse::unsafe_arena_release_funds_sufficiency_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.funds_sufficiency_level)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::tinkoff::public_::invest::api::contract::v1::Quotation* temp = _impl_.funds_sufficiency_level_;
  _impl_.funds_sufficiency_level_ = nullptr;
  return temp;
}
inline ::tinkoff::public_::invest::api::contract::v1::Quotation* GetMarginAttributesResponse::_internal_mutable_funds_sufficiency_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.funds_sufficiency_level_ == nullptr) {
    auto* p = CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::Quotation>(GetArena());
    _impl_.funds_sufficiency_level_ = reinterpret_cast<::tinkoff::public_::invest::api::contract::v1::Quotation*>(p);
  }
  return _impl_.funds_sufficiency_level_;
}
inline ::tinkoff::public_::invest::api::contract::v1::Quotation* GetMarginAttributesResponse::mutable_funds_sufficiency_level() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tinkoff::public_::invest::api::contract::v1::Quotation* _msg = _internal_mutable_funds_sufficiency_level();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.funds_sufficiency_level)
  return _msg;
}
inline void GetMarginAttributesResponse::set_allocated_funds_sufficiency_level(::tinkoff::public_::invest::api::contract::v1::Quotation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.funds_sufficiency_level_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.funds_sufficiency_level_ = reinterpret_cast<::tinkoff::public_::invest::api::contract::v1::Quotation*>(value);
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.funds_sufficiency_level)
}

// .tinkoff.public_.invest.api.contract.v1.MoneyValue amount_of_missing_funds = 5;
inline bool GetMarginAttributesResponse::has_amount_of_missing_funds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.amount_of_missing_funds_ != nullptr);
  return value;
}
inline const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& GetMarginAttributesResponse::_internal_amount_of_missing_funds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue* p = _impl_.amount_of_missing_funds_;
  return p != nullptr ? *p : reinterpret_cast<const ::tinkoff::public_::invest::api::contract::v1::MoneyValue&>(::tinkoff::public_::invest::api::contract::v1::_MoneyValue_default_instance_);
}
inline const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& GetMarginAttributesResponse::amount_of_missing_funds() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.amount_of_missing_funds)
  return _internal_amount_of_missing_funds();
}
inline void GetMarginAttributesResponse::unsafe_arena_set_allocated_amount_of_missing_funds(::tinkoff::public_::invest::api::contract::v1::MoneyValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.amount_of_missing_funds_);
  }
  _impl_.amount_of_missing_funds_ = reinterpret_cast<::tinkoff::public_::invest::api::contract::v1::MoneyValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.amount_of_missing_funds)
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::release_amount_of_missing_funds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* released = _impl_.amount_of_missing_funds_;
  _impl_.amount_of_missing_funds_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::unsafe_arena_release_amount_of_missing_funds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.amount_of_missing_funds)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* temp = _impl_.amount_of_missing_funds_;
  _impl_.amount_of_missing_funds_ = nullptr;
  return temp;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::_internal_mutable_amount_of_missing_funds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.amount_of_missing_funds_ == nullptr) {
    auto* p = CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::MoneyValue>(GetArena());
    _impl_.amount_of_missing_funds_ = reinterpret_cast<::tinkoff::public_::invest::api::contract::v1::MoneyValue*>(p);
  }
  return _impl_.amount_of_missing_funds_;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::mutable_amount_of_missing_funds() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* _msg = _internal_mutable_amount_of_missing_funds();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.amount_of_missing_funds)
  return _msg;
}
inline void GetMarginAttributesResponse::set_allocated_amount_of_missing_funds(::tinkoff::public_::invest::api::contract::v1::MoneyValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.amount_of_missing_funds_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.amount_of_missing_funds_ = reinterpret_cast<::tinkoff::public_::invest::api::contract::v1::MoneyValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.amount_of_missing_funds)
}

// .tinkoff.public_.invest.api.contract.v1.MoneyValue corrected_margin = 6;
inline bool GetMarginAttributesResponse::has_corrected_margin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.corrected_margin_ != nullptr);
  return value;
}
inline const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& GetMarginAttributesResponse::_internal_corrected_margin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::tinkoff::public_::invest::api::contract::v1::MoneyValue* p = _impl_.corrected_margin_;
  return p != nullptr ? *p : reinterpret_cast<const ::tinkoff::public_::invest::api::contract::v1::MoneyValue&>(::tinkoff::public_::invest::api::contract::v1::_MoneyValue_default_instance_);
}
inline const ::tinkoff::public_::invest::api::contract::v1::MoneyValue& GetMarginAttributesResponse::corrected_margin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.corrected_margin)
  return _internal_corrected_margin();
}
inline void GetMarginAttributesResponse::unsafe_arena_set_allocated_corrected_margin(::tinkoff::public_::invest::api::contract::v1::MoneyValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.corrected_margin_);
  }
  _impl_.corrected_margin_ = reinterpret_cast<::tinkoff::public_::invest::api::contract::v1::MoneyValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.corrected_margin)
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::release_corrected_margin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* released = _impl_.corrected_margin_;
  _impl_.corrected_margin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::unsafe_arena_release_corrected_margin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.corrected_margin)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* temp = _impl_.corrected_margin_;
  _impl_.corrected_margin_ = nullptr;
  return temp;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::_internal_mutable_corrected_margin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.corrected_margin_ == nullptr) {
    auto* p = CreateMaybeMessage<::tinkoff::public_::invest::api::contract::v1::MoneyValue>(GetArena());
    _impl_.corrected_margin_ = reinterpret_cast<::tinkoff::public_::invest::api::contract::v1::MoneyValue*>(p);
  }
  return _impl_.corrected_margin_;
}
inline ::tinkoff::public_::invest::api::contract::v1::MoneyValue* GetMarginAttributesResponse::mutable_corrected_margin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tinkoff::public_::invest::api::contract::v1::MoneyValue* _msg = _internal_mutable_corrected_margin();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.corrected_margin)
  return _msg;
}
inline void GetMarginAttributesResponse::set_allocated_corrected_margin(::tinkoff::public_::invest::api::contract::v1::MoneyValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.corrected_margin_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.corrected_margin_ = reinterpret_cast<::tinkoff::public_::invest::api::contract::v1::MoneyValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.GetMarginAttributesResponse.corrected_margin)
}

// -------------------------------------------------------------------

// GetUserTariffRequest

// -------------------------------------------------------------------

// GetUserTariffResponse

// repeated .tinkoff.public_.invest.api.contract.v1.UnaryLimit unary_limits = 1;
inline int GetUserTariffResponse::_internal_unary_limits_size() const {
  return _internal_unary_limits().size();
}
inline int GetUserTariffResponse::unary_limits_size() const {
  return _internal_unary_limits_size();
}
inline void GetUserTariffResponse::clear_unary_limits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.unary_limits_.Clear();
}
inline ::tinkoff::public_::invest::api::contract::v1::UnaryLimit* GetUserTariffResponse::mutable_unary_limits(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse.unary_limits)
  return _internal_mutable_unary_limits()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tinkoff::public_::invest::api::contract::v1::UnaryLimit>* GetUserTariffResponse::mutable_unary_limits()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse.unary_limits)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_unary_limits();
}
inline const ::tinkoff::public_::invest::api::contract::v1::UnaryLimit& GetUserTariffResponse::unary_limits(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse.unary_limits)
  return _internal_unary_limits().Get(index);
}
inline ::tinkoff::public_::invest::api::contract::v1::UnaryLimit* GetUserTariffResponse::add_unary_limits() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::tinkoff::public_::invest::api::contract::v1::UnaryLimit* _add = _internal_mutable_unary_limits()->Add();
  // @@protoc_insertion_point(field_add:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse.unary_limits)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tinkoff::public_::invest::api::contract::v1::UnaryLimit>& GetUserTariffResponse::unary_limits() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse.unary_limits)
  return _internal_unary_limits();
}
inline const ::google::protobuf::RepeatedPtrField<::tinkoff::public_::invest::api::contract::v1::UnaryLimit>&
GetUserTariffResponse::_internal_unary_limits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unary_limits_;
}
inline ::google::protobuf::RepeatedPtrField<::tinkoff::public_::invest::api::contract::v1::UnaryLimit>*
GetUserTariffResponse::_internal_mutable_unary_limits() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.unary_limits_;
}

// repeated .tinkoff.public_.invest.api.contract.v1.StreamLimit stream_limits = 2;
inline int GetUserTariffResponse::_internal_stream_limits_size() const {
  return _internal_stream_limits().size();
}
inline int GetUserTariffResponse::stream_limits_size() const {
  return _internal_stream_limits_size();
}
inline void GetUserTariffResponse::clear_stream_limits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stream_limits_.Clear();
}
inline ::tinkoff::public_::invest::api::contract::v1::StreamLimit* GetUserTariffResponse::mutable_stream_limits(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse.stream_limits)
  return _internal_mutable_stream_limits()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tinkoff::public_::invest::api::contract::v1::StreamLimit>* GetUserTariffResponse::mutable_stream_limits()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse.stream_limits)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_stream_limits();
}
inline const ::tinkoff::public_::invest::api::contract::v1::StreamLimit& GetUserTariffResponse::stream_limits(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse.stream_limits)
  return _internal_stream_limits().Get(index);
}
inline ::tinkoff::public_::invest::api::contract::v1::StreamLimit* GetUserTariffResponse::add_stream_limits() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::tinkoff::public_::invest::api::contract::v1::StreamLimit* _add = _internal_mutable_stream_limits()->Add();
  // @@protoc_insertion_point(field_add:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse.stream_limits)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tinkoff::public_::invest::api::contract::v1::StreamLimit>& GetUserTariffResponse::stream_limits() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tinkoff.public_.invest.api.contract.v1.GetUserTariffResponse.stream_limits)
  return _internal_stream_limits();
}
inline const ::google::protobuf::RepeatedPtrField<::tinkoff::public_::invest::api::contract::v1::StreamLimit>&
GetUserTariffResponse::_internal_stream_limits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stream_limits_;
}
inline ::google::protobuf::RepeatedPtrField<::tinkoff::public_::invest::api::contract::v1::StreamLimit>*
GetUserTariffResponse::_internal_mutable_stream_limits() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.stream_limits_;
}

// -------------------------------------------------------------------

// UnaryLimit

// int32 limit_per_minute = 1;
inline void UnaryLimit::clear_limit_per_minute() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.limit_per_minute_ = 0;
}
inline ::int32_t UnaryLimit::limit_per_minute() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.UnaryLimit.limit_per_minute)
  return _internal_limit_per_minute();
}
inline void UnaryLimit::set_limit_per_minute(::int32_t value) {
  _internal_set_limit_per_minute(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.UnaryLimit.limit_per_minute)
}
inline ::int32_t UnaryLimit::_internal_limit_per_minute() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.limit_per_minute_;
}
inline void UnaryLimit::_internal_set_limit_per_minute(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.limit_per_minute_ = value;
}

// repeated string methods = 2;
inline int UnaryLimit::_internal_methods_size() const {
  return _internal_methods().size();
}
inline int UnaryLimit::methods_size() const {
  return _internal_methods_size();
}
inline void UnaryLimit::clear_methods() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.methods_.Clear();
}
inline std::string* UnaryLimit::add_methods()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_methods()->Add();
  // @@protoc_insertion_point(field_add_mutable:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
  return _s;
}
inline const std::string& UnaryLimit::methods(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
  return _internal_methods().Get(index);
}
inline std::string* UnaryLimit::mutable_methods(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
  return _internal_mutable_methods()->Mutable(index);
}
inline void UnaryLimit::set_methods(int index, const std::string& value) {
  _internal_mutable_methods()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
}
inline void UnaryLimit::set_methods(int index, std::string&& value) {
  _internal_mutable_methods()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
}
inline void UnaryLimit::set_methods(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_methods()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
}
inline void UnaryLimit::set_methods(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_methods()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
}
inline void UnaryLimit::set_methods(int index, absl::string_view value) {
  _internal_mutable_methods()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
}
inline void UnaryLimit::add_methods(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_methods()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
}
inline void UnaryLimit::add_methods(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_methods()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
}
inline void UnaryLimit::add_methods(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_methods()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
}
inline void UnaryLimit::add_methods(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_methods()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
}
inline void UnaryLimit::add_methods(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_methods()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UnaryLimit::methods() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
  return _internal_methods();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UnaryLimit::mutable_methods() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tinkoff.public_.invest.api.contract.v1.UnaryLimit.methods)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_methods();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UnaryLimit::_internal_methods() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.methods_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UnaryLimit::_internal_mutable_methods() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.methods_;
}

// -------------------------------------------------------------------

// StreamLimit

// int32 limit = 1;
inline void StreamLimit::clear_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.limit_ = 0;
}
inline ::int32_t StreamLimit::limit() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.StreamLimit.limit)
  return _internal_limit();
}
inline void StreamLimit::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.StreamLimit.limit)
}
inline ::int32_t StreamLimit::_internal_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.limit_;
}
inline void StreamLimit::_internal_set_limit(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.limit_ = value;
}

// repeated string streams = 2;
inline int StreamLimit::_internal_streams_size() const {
  return _internal_streams().size();
}
inline int StreamLimit::streams_size() const {
  return _internal_streams_size();
}
inline void StreamLimit::clear_streams() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.streams_.Clear();
}
inline std::string* StreamLimit::add_streams()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_streams()->Add();
  // @@protoc_insertion_point(field_add_mutable:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
  return _s;
}
inline const std::string& StreamLimit::streams(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
  return _internal_streams().Get(index);
}
inline std::string* StreamLimit::mutable_streams(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
  return _internal_mutable_streams()->Mutable(index);
}
inline void StreamLimit::set_streams(int index, const std::string& value) {
  _internal_mutable_streams()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
}
inline void StreamLimit::set_streams(int index, std::string&& value) {
  _internal_mutable_streams()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
}
inline void StreamLimit::set_streams(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_streams()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
}
inline void StreamLimit::set_streams(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_streams()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
}
inline void StreamLimit::set_streams(int index, absl::string_view value) {
  _internal_mutable_streams()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
}
inline void StreamLimit::add_streams(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_streams()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
}
inline void StreamLimit::add_streams(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_streams()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
}
inline void StreamLimit::add_streams(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_streams()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
}
inline void StreamLimit::add_streams(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_streams()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
}
inline void StreamLimit::add_streams(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_streams()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StreamLimit::streams() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
  return _internal_streams();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StreamLimit::mutable_streams() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tinkoff.public_.invest.api.contract.v1.StreamLimit.streams)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_streams();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StreamLimit::_internal_streams() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.streams_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StreamLimit::_internal_mutable_streams() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.streams_;
}

// int32 open = 3;
inline void StreamLimit::clear_open() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.open_ = 0;
}
inline ::int32_t StreamLimit::open() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.StreamLimit.open)
  return _internal_open();
}
inline void StreamLimit::set_open(::int32_t value) {
  _internal_set_open(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.StreamLimit.open)
}
inline ::int32_t StreamLimit::_internal_open() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.open_;
}
inline void StreamLimit::_internal_set_open(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.open_ = value;
}

// -------------------------------------------------------------------

// GetInfoRequest

// -------------------------------------------------------------------

// GetInfoResponse

// bool prem_status = 1;
inline void GetInfoResponse::clear_prem_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.prem_status_ = false;
}
inline bool GetInfoResponse::prem_status() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.prem_status)
  return _internal_prem_status();
}
inline void GetInfoResponse::set_prem_status(bool value) {
  _internal_set_prem_status(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.prem_status)
}
inline bool GetInfoResponse::_internal_prem_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.prem_status_;
}
inline void GetInfoResponse::_internal_set_prem_status(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.prem_status_ = value;
}

// bool qual_status = 2;
inline void GetInfoResponse::clear_qual_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.qual_status_ = false;
}
inline bool GetInfoResponse::qual_status() const {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qual_status)
  return _internal_qual_status();
}
inline void GetInfoResponse::set_qual_status(bool value) {
  _internal_set_qual_status(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qual_status)
}
inline bool GetInfoResponse::_internal_qual_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.qual_status_;
}
inline void GetInfoResponse::_internal_set_qual_status(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.qual_status_ = value;
}

// repeated string qualified_for_work_with = 3;
inline int GetInfoResponse::_internal_qualified_for_work_with_size() const {
  return _internal_qualified_for_work_with().size();
}
inline int GetInfoResponse::qualified_for_work_with_size() const {
  return _internal_qualified_for_work_with_size();
}
inline void GetInfoResponse::clear_qualified_for_work_with() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.qualified_for_work_with_.Clear();
}
inline std::string* GetInfoResponse::add_qualified_for_work_with()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_qualified_for_work_with()->Add();
  // @@protoc_insertion_point(field_add_mutable:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
  return _s;
}
inline const std::string& GetInfoResponse::qualified_for_work_with(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
  return _internal_qualified_for_work_with().Get(index);
}
inline std::string* GetInfoResponse::mutable_qualified_for_work_with(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
  return _internal_mutable_qualified_for_work_with()->Mutable(index);
}
inline void GetInfoResponse::set_qualified_for_work_with(int index, const std::string& value) {
  _internal_mutable_qualified_for_work_with()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
}
inline void GetInfoResponse::set_qualified_for_work_with(int index, std::string&& value) {
  _internal_mutable_qualified_for_work_with()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
}
inline void GetInfoResponse::set_qualified_for_work_with(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_qualified_for_work_with()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
}
inline void GetInfoResponse::set_qualified_for_work_with(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_qualified_for_work_with()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
}
inline void GetInfoResponse::set_qualified_for_work_with(int index, absl::string_view value) {
  _internal_mutable_qualified_for_work_with()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
}
inline void GetInfoResponse::add_qualified_for_work_with(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_qualified_for_work_with()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
}
inline void GetInfoResponse::add_qualified_for_work_with(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_qualified_for_work_with()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
}
inline void GetInfoResponse::add_qualified_for_work_with(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_qualified_for_work_with()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
}
inline void GetInfoResponse::add_qualified_for_work_with(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_qualified_for_work_with()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
}
inline void GetInfoResponse::add_qualified_for_work_with(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_qualified_for_work_with()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetInfoResponse::qualified_for_work_with() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
  return _internal_qualified_for_work_with();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetInfoResponse::mutable_qualified_for_work_with() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.qualified_for_work_with)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_qualified_for_work_with();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetInfoResponse::_internal_qualified_for_work_with() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.qualified_for_work_with_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetInfoResponse::_internal_mutable_qualified_for_work_with() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.qualified_for_work_with_;
}

// string tariff = 4;
inline void GetInfoResponse::clear_tariff() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tariff_.ClearToEmpty();
}
inline const std::string& GetInfoResponse::tariff() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.tariff)
  return _internal_tariff();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetInfoResponse::set_tariff(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tariff_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.tariff)
}
inline std::string* GetInfoResponse::mutable_tariff() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tariff();
  // @@protoc_insertion_point(field_mutable:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.tariff)
  return _s;
}
inline const std::string& GetInfoResponse::_internal_tariff() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tariff_.Get();
}
inline void GetInfoResponse::_internal_set_tariff(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tariff_.Set(value, GetArena());
}
inline std::string* GetInfoResponse::_internal_mutable_tariff() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.tariff_.Mutable( GetArena());
}
inline std::string* GetInfoResponse::release_tariff() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.tariff)
  return _impl_.tariff_.Release();
}
inline void GetInfoResponse::set_allocated_tariff(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tariff_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tariff_.IsDefault()) {
          _impl_.tariff_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tinkoff.public_.invest.api.contract.v1.GetInfoResponse.tariff)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace contract
}  // namespace api
}  // namespace invest
}  // namespace public_
}  // namespace tinkoff


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::tinkoff::public_::invest::api::contract::v1::AccountType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::tinkoff::public_::invest::api::contract::v1::AccountType>() {
  return ::tinkoff::public_::invest::api::contract::v1::AccountType_descriptor();
}
template <>
struct is_proto_enum<::tinkoff::public_::invest::api::contract::v1::AccountStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::tinkoff::public_::invest::api::contract::v1::AccountStatus>() {
  return ::tinkoff::public_::invest::api::contract::v1::AccountStatus_descriptor();
}
template <>
struct is_proto_enum<::tinkoff::public_::invest::api::contract::v1::AccessLevel> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::tinkoff::public_::invest::api::contract::v1::AccessLevel>() {
  return ::tinkoff::public_::invest::api::contract::v1::AccessLevel_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_users_2eproto_2epb_2eh
